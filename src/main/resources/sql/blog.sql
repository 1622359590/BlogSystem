/*
Navicat MySQL Data Transfer

Source Server         : aimeimeiTS
Source Server Version : 50716
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50716
File Encoding         : 65001

Date: 2018-04-03 14:10:00
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `blog`
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '博文id',
  `blogger_id` int(11) unsigned NOT NULL COMMENT '博文所属博主id',
  `category_ids` varchar(100) DEFAULT NULL COMMENT '博文所属类别id（用特定字符分隔）',
  `label_ids` varchar(100) DEFAULT NULL COMMENT '博文包含的标签（用特定字符分隔）',
  `state` int(11) NOT NULL DEFAULT '0' COMMENT '文章状态（公开，私有，审核中，回收站...）',
  `title` varchar(80) NOT NULL COMMENT '博文标题',
  `content` longtext NOT NULL COMMENT '博文主体内容html格式',
  `content_md` longtext NOT NULL COMMENT '博文主题内容md格式',
  `summary` varchar(400) NOT NULL COMMENT '博文摘要',
  `release_date` datetime NOT NULL COMMENT '首次发布日期',
  `nearest_modify_date` datetime NOT NULL COMMENT '最后一次修改时间',
  `key_words` varchar(400) DEFAULT NULL COMMENT '博文关键字（空格分隔）',
  `word_count` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '博文字数',
  PRIMARY KEY (`id`),
  UNIQUE KEY `blogger_id` (`blogger_id`,`title`),
  CONSTRAINT `blog_ibfk_1` FOREIGN KEY (`blogger_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=180 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('141', '22', '29 28', '49', '1', 'java 线程浅析', '<h3 id=\"h3-u7EBFu7A0Bu4F18u5148u7EA7\"><a name=\"线程优先级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程优先级</h3><p>线程的优先级用数字表示，范围为1~10，默认为5.<br>每个线程的默认优先级与创建它的父线程相同。数字越大，优先级越高。<br>Thread类提供了三个常量明确了线程优先级的边界：</p>\n<p>', '### 线程优先级\n线程的优先级用数字表示，范围为1~10，默认为5.\n每个线程的默认优先级与创建它的父线程相同。数字越大，优先级越高。\nThread类提供了三个常量明确了线程优先级的边界：\n<p>MAX_PRIORITY (10)  //最大优先级\nMIN_PRIORITY (1)   //最小优先级\nNORM_PRIORITY (5) //中等优先级\n</P>\n![这里写图片描述](http://img.blog.csdn.net/20171216152628286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n### 线程的终止\nThread.stop方法已经废弃，线程终止线程的根本原则是使run方法运行结束（run方法返回线程就会结束）。Runable的run方法定义中并声明异常，所以终止线程的方法就是run方法返回。\n\n**终止处于“阻塞状态”的线程**\n<p>通常，我们通过“中断”方式终止处于“阻塞状态”的线程（即调用线程的interrupt方法）。线程由于调用了sleep(), wait(), join()等方法而进入阻塞状态（这些方法都会抛出InterruptException）；若此时调用线程的interrupt()将线程的中断标记设为true。则线程将产生一个InterruptedException异常（阻塞方法将收到此异常），同时中断标记会被清除（置为false）。\n<p>那么只需在收到InterruptException异常时终止run方法执行即可。\n![这里写图片描述](http://img.blog.csdn.net/20171216153000245?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n**终止处于“运行状态”的线程**\n<P>使用“中断标记”，或添加“额外的结束标记”的方式判断线程是否需要结束。\n如：调用isInterrupt()判断中断标记是否为true，在需要结束的地方调用线程的interrupt方法。\n![这里写图片描述](http://img.blog.csdn.net/20171216152825117?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n### 线程的五种状态\n线程从创建运行到结束总是处于下面五个状态之一：**新建状态、就绪状态、运行状态、阻塞状态及死亡状态。**\n![这里写图片描述](http://img.blog.csdn.net/20171216153100804?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n#### 新建状态(new)\n当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行（未调用其start方法），此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码。\n####就绪状态(Runnable)\n一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于**就绪状态**。\n\n<u>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。</u> 因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。\n####运行状态(Running)\n当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法\n####阻塞状态(Blocked)\n线程运行过程中，可能由于各种原因进入阻塞状态:\n1.	线程通过调用sleep方法进入睡眠状态；\n2.	线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；\n3.	线程试图得到一个锁，而该锁正被其他线程持有（死锁）。\n4.	线程在等待某个触发条件；\n...... \n\n所谓阻塞状态是<u>正在运行的线程没有运行结束，暂时让出CPU</u>，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。\n#### 死亡状态(Dead)\n有两个原因会导致线程死亡：\n1.	run方法正常退出而自然死亡\n2.	一个未捕获的异常终止了run方法而使线程猝死。\n\n为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.\n\n###Object的wait，notify，notifyAll方法\nwait()，notify()和notifyAll()方法只能在同步方法或同步代码块里调用。\n使用示例：\n![这里写图片描述](http://img.blog.csdn.net/20171216153556511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n输出：\n06/12/2017 16:27:13-176 wake up main thread after 3 seconds\n06/12/2017 16:27:16-179  i`m wake up\n###Thread.sleep和wait区别\n\n####Thread.sleep(mills)\nsleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会**让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持**，因此休眠时间结束后会自动恢复（线程回到<u>就绪状态，已获得锁，等待CPU调度</u>）\n\n####Object.wait(mills)\nwait()是Object类的方法，调用对象的wait()方法导致**当前线程放弃对象的锁**（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lockpool），如果线程重新获得对象的锁就可以进入就绪状态。\n###IllegalMonitorStateException\n如果在非同步控制方法里调用这些方法（Object的wait、notify、notifyAll），程序能通过编译，但运行的时候，将得到IllegalMonitorStateException异常，并伴随着一些含糊的消息，比如\"当前线程不是拥有者\"。消息的意思是，**调用wait()，notify()和notifyAll()的线程在调用这些方法前必须\"拥有\"对象的锁。**当前的线程不是此对象锁的所有者，却调用该对象的notify()，notify()，wait()方法时抛出该异常。\n如下几种情况都会得到该异常：\n![这里写图片描述](http://img.blog.csdn.net/20171216154108599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n-----\n<center>-------END----</center>', '一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。', '2018-03-07 16:44:53', '2018-03-07 17:20:16', null, '6000');
INSERT INTO `blog` VALUES ('142', '22', '27 29', '49', '1', 'java 8 新特性小结', '<p>参考文章链接<br><a href=\"http://www.importnew.com/16436.html\">Java8 lambda表达式10个示例</a><br><a href=\"http://www.importnew.com/11908.html\">Java 8新特性终极指南</a></p>\n<h3 id=\"h3-u5C0Fu7ED3\"><a name=\"小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>小结</h3><p>1．    Lambda表达式（闭包）；<br>2．    函数式编程支持： java.util.function.* 下的众多接口；<br>3．    流API；<br>4．    接口的默认方法和静态方法；<br>5．    新的Date和Time API。</p>\n<h3 id=\"h3-1-optional-\"><a name=\"1 Optional 接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Optional 接口</h3><p><a href=\"http://www.importnew.com/6675.html\">Java 8 Optional类深度解析</a><br>Optional 类对对象的 null 值检测进行包装，如果值存在则 isPresent 返回true，否则 false。</p>\n<h4 id=\"h4-u4E3Bu8981u65B9u6CD5\"><a name=\"主要方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>主要方法</h4><ol>\n<li>Optional.of：创建一个Optional，不能为null，赋值抛出NullPointerException。</li><li>Optional.ofNullable：创建一个可以为 null 的 Optional。</li><li>isPresent：值存在返回true，否则false。</li><li>ifPresent：值存在就调用Consumer对象的accept方法，否则无任何动作。</li><li>get：返回值，空Optional抛NoSuchElementException异常。</li><li>orElse：值存在返回，否则返回指定值。</li><li>orElseGet：值存在返回，否则调用Supplier的get返回。</li><li>orElseThrow：存在返回，否则抛出指定异常。<br>map、flatMap、filter</li></ol>\n<h3 id=\"h3-2-lambda\"><a name=\"2 Lambda\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Lambda</h3><p>Lambda表达式允许将函数作为一个方法参数传递，或许将代码看成数据。<br>用 () -', '参考文章链接\n[Java8 lambda表达式10个示例](http://www.importnew.com/16436.html )\n[Java 8新特性终极指南](http://www.importnew.com/11908.html )\n\n### 小结\n1．	Lambda表达式（闭包）；\n2．	函数式编程支持： java.util.function.* 下的众多接口；\n3．	流API；\n4．	接口的默认方法和静态方法；\n5．	新的Date和Time API。\n\n###  1 Optional 接口\n[Java 8 Optional类深度解析](http://www.importnew.com/6675.html )\nOptional 类对对象的 null 值检测进行包装，如果值存在则 isPresent 返回true，否则 false。\n\n#### 主要方法\n\n1. Optional.of：创建一个Optional，不能为null，赋值抛出NullPointerException。\n2. Optional.ofNullable：创建一个可以为 null 的 Optional。\n3. isPresent：值存在返回true，否则false。\n4. ifPresent：值存在就调用Consumer对象的accept方法，否则无任何动作。\n5. get：返回值，空Optional抛NoSuchElementException异常。\n6. orElse：值存在返回，否则返回指定值。\n7. orElseGet：值存在返回，否则调用Supplier的get返回。\n8. orElseThrow：存在返回，否则抛出指定异常。\nmap、flatMap、filter\n\n### 2 Lambda\nLambda表达式允许将函数作为一个方法参数传递，或许将代码看成数据。\n用 () -> {} 代替整个匿名类。\n<java>\nnew Thread( () -> {int i = 9 ; System.out.println(“somting” i) ; }).start();\n</java>\n() 中参数可省略类型，没有参数时 () 仍然要保留。\n{} 只有一条语句时 {} 可以省略，语句尾的 ; 也可以省略。\n<java>\nArrays.asList(“a”, “b”, “c”, “d”).forEach(va -> System.out.println(va));\n</java>\n\n### 3 FunctionalInterface\n函数式接口，如果一个接口只有一个方法，那么编译器会将该接口视为函数式接口，如果在接口上加 FunctionalInterface 注解，那么接口就会被强制要求符合函数式接口的规范（只有一个抽象方法，默认，静态方法不包括在内）。\n### 4 Predicate 接口\n适用于过滤元素。\n该接口有一个test方法，返回boolean，表示检查结果。提供了类似于逻辑操作符AND和OR的方法and()、or()、xor()。可以将多个条件进行组合。\n<java>\nPredicate<String> testStart = (str) -> str.startsWith(\"a\");\nPredicate<String> testContain = (str) -> str.contains(\"b\");\nboolean result = testStart.and(testContain).test(\"acvvb\"); // true\n</java>\n### 5 Map 的 Reduce\n使用示例：map方法（Function接口）遍历并将每一个数乘以2，reduce（BiFunction接口）方法将结果汇总于sum。\n<java>\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);\nOptional<Integer> reduce = list.stream().map(va -> va >> 1).reduce((sum, cur) -> sum  = cur);\no.accept(reduce.orElse(-1));\n</java>\n### 6 Function<T,R> 接口\n用于产生对象，函数式接口，接受一个参数，构造并返回目标对象。\n<java>\nR apply(T t);\n</java>\n### 7 BiFunction<T,R,U>接口\n用于产生对象，接受两个参数，生成一个结果。\n<java>\nR apply(T t,U u);\n</java>\n### 8 过滤集合元素\n示例：Filter方法（Predicate接口）遍历元素并检查，返回true保留，collect方法（Collector接口）将结果组合为新的集合。\n<java>\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);\nList<Integer> collect = list.stream().filter(va -> va  2 == 0).collect(Collectors.toList());\no.accept(collect);\n</java>\n### 9 Supplier接口\n用来产生对象\n<java>\nT get();\n</java>\n### 10 计算集合元素的最大，最小，总和以及平均值\nIntStream、LongStream和DoubleStream中有个summaryStatics方法，可以返回IntSummaryStatics、LongSummaryStatics或DoubleSummaryStatics，描述流中的各种摘要数据。\nStream的mapToInt/Long/Double方法可将指定对象作为参数，产生对应的基本类型，mapXXX中接受的接口为：ToInt/Long/DoubleFunction，方法为(以int为例)：int applyToInt(T value);\n<java>\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);\nIntSummaryStatistics statistics = list.stream().mapToInt(i -> i).summaryStatistics();\nstatistics.getMax();\nstatistics.getMin();\nstatistics.getAverage();\nstatistics.getSum();\nstatistics.getCount();\n</java>\n### 11 Lambda VS 匿名内部类\nthis关键字：匿名类的this指向匿名类，而Lambda的this指向外部类。\n编译方式：Lambda被编译为外部类的私有成员方法，而匿名类被编译为单独的类。\n同：两种方式在引用外部的局部变量时局部变量要被final修饰。\n11 方法引用\nList<Car> cars = new ArrayList<>();\n1.	方法构造器（无参可访问的构造器）引用：Class::new ，可以便捷的创建一个对象，通常配合Supplier接口使用。\n2.	引用静态方法（一参可访问）：Class::static_method，通常配合Consumer接口使用。\n3.	引用特定类的方法（无参可访问）：Class::method\n4.	引用特定对象的方法：instance::method\n\n### 12 新的Date/Time API\n在java.time.*包下：\n新的API涵盖了所有处理日期、时间、时区、过程与时钟的操作。\n#### (1) Clock类\nUTC（Universal Time Coordinated）为世界协调时间，与格林尼治时间一样，与英国伦敦时间也一样。北京是东八区，领先于UTC8个小时。\n<java>\nClock clock = Clock.systemUTC();\n        Instant instant = clock.instant();\n        Instant plus = instant.plus(8, ChronoUnit.HOURS);// 加 8 小时\n\n        Instant minus = instant\n//                .plus(24 * 60 * 60 * 1000, ChronoUnit.MILLIS) // 加一天\n                .minus(24 * 60 * 60 * 1000, ChronoUnit.MILLIS);// 减一天\n        o.accept(instant); // UTC 时间：2017-10-24T07:11:12.576Z\n        o.accept(plus);// 北京时间：2017-10-24T15:11:12.576Z\n        o.accept(minus);// UTC 时间减一天：2017-10-23T07:11:12.576Z\n</java>\n#### (2) LocalDate、LocalTime和LocalDateTime\n三者只持有ISO-8601格式具有时区信息的日期与时间。前两者都可以从Clock中获得。\n<java>\nClock clock = Clock.systemUTC();\nLocalDate date = LocalDate.now();\nLocalTime time = LocalTime.now(clock);\nLocalDateTime dateTime = LocalDateTime.now();\no.accept(date); //2017-10-24\no.accept(time); // 07:22:07.781 系统时间：15:22:37.050\no.accept(time.getNano()); // 319000000\no.accept(dateTime); // 2017-10-24T15:23:54.109\n</java>\n#### (3) Duration\n在秒与纳秒级别上的一段时间。简化了计算两个时间差的不同。\n<java>\nDuration duration = Duration.between(\n        LocalDateTime.of(2014, Month.JULY, 13, 21, 0, 0),        // 2014-07-13 21:00:00\n        LocalDateTime.of(2014, Month.JULY, 14, 22, 13, 16));      // 2014-07-14 22:13:16\no.accept(duration.toDays()); // 1\no.accept(duration.toHours()); // 25\no.accept(duration.toMinutes()); // 1513\no.accept(duration.toNanos()); // 90796000000000\n</java>\n\n---\n<center>--- END ---</center>', 'Lambda表达式允许将函数作为一个方法参数传递，或许将代码看成数据。\n用 () -> {} 代替整个匿名类。', '2018-03-08 13:22:25', '2018-03-08 13:29:13', null, '6358');
INSERT INTO `blog` VALUES ('162', '22', '', '', '1', 'java nio 入门-', '<p>java nio 入门</p>\n', 'java nio 入门', 'java nio 入门', '2018-03-09 13:47:04', '2018-03-09 13:47:04', null, '19');
INSERT INTO `blog` VALUES ('163', '22', '27', '', '1', '调用缓冲器的flip方法', '<h2 id=\"h2-u57FAu672Cu4F7Fu7528\"><a name=\"基本使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本使用</h2><p>通过ByteBuffer与通道打交道。<br><img src=\"http://img.blog.csdn.net/20180112155617972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>在当缓冲器中的数据即将被读取之前，需要调用缓冲器的flip方法，让缓冲器做好被读取的准备，这样能获得更快的速度；当缓冲器需要重新填充数据时，调用缓冲器的clear方法清除缓存数据。</p>\n<p>上述方法完成了tip.txt文件的复制。也可以通过下面的transferTo方法实现：<br> <img src=\"http://img.blog.csdn.net/20180112155635608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3 id=\"h3-u5C06u5B57u8282u7F16u7801u4E3Au5B57u7B26\"><a name=\"将字节编码为字符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>将字节编码为字符</h3><p>如果直接将字节读取并转换将无法正确解码，同样的直接使用ByteBuffer的asCharBuffer并调用CharBuffer的toString方法也将产生编码错误，因为不知道字符是如何编码的，也就无法正确解码。</p>\n<p>使用平台默认编码解码：<br> <img src=\"http://img.blog.csdn.net/20180112160027504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>以字符的形式写入之后再读取：<br> <img src=\"http://img.blog.csdn.net/20180112160039852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>存入时指定字符集：<br> <img src=\"http://img.blog.csdn.net/20180112160106058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n', '\n## 基本使用\n通过ByteBuffer与通道打交道。\n![这里写图片描述](http://img.blog.csdn.net/20180112155617972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n在当缓冲器中的数据即将被读取之前，需要调用缓冲器的flip方法，让缓冲器做好被读取的准备，这样能获得更快的速度；当缓冲器需要重新填充数据时，调用缓冲器的clear方法清除缓存数据。\n \n上述方法完成了tip.txt文件的复制。也可以通过下面的transferTo方法实现：\n ![这里写图片描述](http://img.blog.csdn.net/20180112155635608?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n### 将字节编码为字符\n如果直接将字节读取并转换将无法正确解码，同样的直接使用ByteBuffer的asCharBuffer并调用CharBuffer的toString方法也将产生编码错误，因为不知道字符是如何编码的，也就无法正确解码。\n\n使用平台默认编码解码：\n ![这里写图片描述](http://img.blog.csdn.net/20180112160027504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n以字符的形式写入之后再读取：\n ![这里写图片描述](http://img.blog.csdn.net/20180112160039852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n存入时指定字符集：\n ![这里写图片描述](http://img.blog.csdn.net/20180112160106058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n ', '在当缓冲器中的数据即将被读取之前，需要调用缓冲器的flip方法，让缓冲器做好被读取的准备，这样能获得更快的速度；当缓冲器需要重新填充数据时，调用缓冲器的clear方法清除缓存数据。\n\n上述方法完成了tip.txt文件的复制。也可以通过下面的transferTo方法实现：', '2018-03-09 14:22:35', '2018-03-09 14:22:35', null, '1697');
INSERT INTO `blog` VALUES ('165', '22', '29', '', '1', '调用缓冲器的flip方法11', '<p>调用缓冲器的flip方法</p>\n', '调用缓冲器的flip方法', '调用缓冲器的flip方法', '2018-03-09 14:23:30', '2018-03-09 14:23:30', null, '20');
INSERT INTO `blog` VALUES ('166', '22', '', '', '1', 'ByteBuffer', '<h2 id=\"h2-bytebuffer\"><a name=\"ByteBuffer\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ByteBuffer</h2><p>ByteBuffer是将数据移进移出通道的唯一方式，并且我们只能创建一个独立的基本类型缓冲器（ByteBuffer，DoubleBuffer，ShortBuffer等），或者使用ByteBuffer的asXXXBuffer方法从ByteBuffer获得。</p>\n<p>ByteBuffer由数据和可以高效操作这些数据的四个索引组成，这四个索引为：</p>\n<ul>\n<li>mark：标记</li><li>position：位置</li><li>limit：界限</li><li>capacity：容量</li></ul>\n', '\n## ByteBuffer\nByteBuffer是将数据移进移出通道的唯一方式，并且我们只能创建一个独立的基本类型缓冲器（ByteBuffer，DoubleBuffer，ShortBuffer等），或者使用ByteBuffer的asXXXBuffer方法从ByteBuffer获得。\n\nByteBuffer由数据和可以高效操作这些数据的四个索引组成，这四个索引为：\n\n- mark：标记\n- position：位置\n- limit：界限\n- capacity：容量', '\n## ByteBuffer\nByteBuffer是将数据移进移出通道的唯一方式，并且我们只能创建一个独立的基本类型缓冲器（ByteBuffer，DoubleBuffer，ShortBuffer等），或者使用ByteBuffer的asXXXBuffer方法从ByteBuffer获得。', '2018-03-09 14:26:56', '2018-03-09 14:26:56', null, '406');
INSERT INTO `blog` VALUES ('167', '1', '1 2', '37 3', '1', 'TCP和UDP', '<p><img src=\"http://upload-images.jianshu.io/upload_images/7460499-3bb051bd514ad9a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>在TCP/IP模型中，&lt;b&gt;UDP和TCP为网络层以上和应用层以下提供接口。&lt;/b&gt;</p>\n<p>&lt;p&gt;&lt;b&gt;TCP/IP协议族四层模型&lt;/b&gt;&lt;/p&gt;<br><img src=\"http://img.blog.csdn.net/20171211200515199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3 id=\"h3-1-tcp\"><a name=\"1. TCP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. TCP</h3><p>参考文章：<a href=\"https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE\">传输控制协议</a><br>Transmission Control Protocol，传输控制协议，是一种&lt;b&gt;面向连接的、可靠的、基于字节流的传输层通信协议。&lt;/b&gt;</p>\n<p>&lt;p&gt;TCP协议的运行可划分为三个阶段：连接创建、数据传送、连接终止。</p>\n<p>应用层向TCP层（传输层）发送用于网间传输的、用8位字节（一个字符）表示的数据流，然后TCP把数据流分区成适当长度的报文段。之后TCP把结果包传给IP层（网络互联层），由它来通过网络将包传送给接收端实体的TCP层。</p>\n<p>TCP为了保证不发生丢包，&lt;u&gt;就给每个包一个序号&lt;/u&gt;，同时序号也保证了传送到接收端实体的包的<strong>按序接收</strong>。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行<strong>丢失（发送端）重传</strong>。TCP用一个<strong>校验和函数</strong>来检验数据是否有错误；在发送和接收时都要计算校验和。</p>\n<h4 id=\"h4-1-1-tcp-\"><a name=\"1.1 TCP的三次握手建立连接\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 TCP的三次握手建立连接</h4><p>简写解释:</p>\n<ul>\n<li>SYN表示建立连接</li><li>FIN表示关闭连接</li><li>ACK表示响应</li><li>PSH表示有DATA数据传输</li><li>RST表示连接重置</li></ul>\n<p><strong>三次握手</strong>：</p>\n<ol>\n<li>客户端向服务器发送一个SYN J （客户端请求）</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1（服务端响应请求）</li><li>客户端再想服务器发一个确认ACK K+1（客户端确认收到服务端响应）</li></ol>\n<p>对应于Socket编程的几个方法的调用顺序为：<br><img src=\"http://img.blog.csdn.net/20171211195124132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>&lt;p&gt;当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求并向客户端发送SYN K（连接请求）和ACK J+1（响应），这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1后connect方法返回，客户端发送ACK K+1进行最终确认；服务端收到ACK K+1后accept返回，至此三次握手完毕，连接建立。&lt;/p&gt;<br><strong>客syn服 -&gt; 服syn+ack客 –&gt; 客ack服</strong></p>\n<h4 id=\"h4-1-2-tcp-\"><a name=\"1.2 TCP的四次握手释放连接\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 TCP的四次握手释放连接</h4><p><strong>四次挥手：</strong></p>\n<ol>\n<li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，对这个FIN进行确认，同时将执行被动关闭；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。<br><img src=\"http://img.blog.csdn.net/20171211195752810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br><strong>客fin服务 -&gt; 服ack客 -&gt; 服fin客 -&gt; 客ack服务</strong><h3 id=\"h3-2-udp\"><a name=\"2.UDP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.UDP</h3>参考文章：<a href=\"https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE\">用户数据报协议</a></li></ol>\n<p>User Datagram Protocol，缩写为UDP，又称用户数据报文协议，是一个<strong>简单的面向数据报的传输层协议</strong>。</p>\n<p>UDP只提供数据的<strong>不可靠传递</strong>，它&lt;u&gt;一旦把应用程序发给网络层的数据发送出去，就不保留数据备份&lt;/u&gt;（所以UDP有时候也被认为是不可靠的数据报协议）。</p>\n<p>UDP在IP数据报的头部仅仅加入了复用和数据校验（字段）。由于缺乏可靠性且属于非连接导向协议，UDP应用一般必须允许一定量的丢包、出错。流媒体（流技术）、即时多媒体游戏和IP电话（VoIP）一定就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（TCP协议）来代替UDP。</p>\n<h3 id=\"h3-3-\"><a name=\"3. 两者区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 两者区别</h3><p><img src=\"http://img.blog.csdn.net/20171211200420262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n', '![](http://upload-images.jianshu.io/upload_images/7460499-3bb051bd514ad9a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在TCP/IP模型中，<b>UDP和TCP为网络层以上和应用层以下提供接口。</b>\n<p><b>TCP/IP协议族四层模型</b></p>\n![这里写图片描述](http://img.blog.csdn.net/20171211200515199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 1. TCP\n参考文章：[传输控制协议](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE )\nTransmission Control Protocol，传输控制协议，是一种<b>面向连接的、可靠的、基于字节流的传输层通信协议。</b>\n<p>TCP协议的运行可划分为三个阶段：连接创建、数据传送、连接终止。\n\n应用层向TCP层（传输层）发送用于网间传输的、用8位字节（一个字符）表示的数据流，然后TCP把数据流分区成适当长度的报文段。之后TCP把结果包传给IP层（网络互联层），由它来通过网络将包传送给接收端实体的TCP层。\n\nTCP为了保证不发生丢包，<u>就给每个包一个序号</u>，同时序号也保证了传送到接收端实体的包的**按序接收**。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行**丢失（发送端）重传**。TCP用一个**校验和函数**来检验数据是否有错误；在发送和接收时都要计算校验和。\n\n#### 1.1 TCP的三次握手建立连接\n简写解释:\n\n-	SYN表示建立连接\n-	FIN表示关闭连接\n-	ACK表示响应\n-	PSH表示有DATA数据传输\n-	RST表示连接重置\n\n**三次握手**：\n1.	客户端向服务器发送一个SYN J （客户端请求）\n2.	服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1（服务端响应请求）\n3.	客户端再想服务器发一个确认ACK K+1（客户端确认收到服务端响应）\n\n对应于Socket编程的几个方法的调用顺序为：\n![这里写图片描述](http://img.blog.csdn.net/20171211195124132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n<p>当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求并向客户端发送SYN K（连接请求）和ACK J+1（响应），这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1后connect方法返回，客户端发送ACK K+1进行最终确认；服务端收到ACK K+1后accept返回，至此三次握手完毕，连接建立。</p>\n**客syn服 -> 服syn+ack客 –> 客ack服**\n#### 1.2 TCP的四次握手释放连接\n**四次挥手：**\n1.	某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；\n2.	另一端接收到FIN M之后，对这个FIN进行确认，同时将执行被动关闭；\n3.	一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；\n4.	接收到这个FIN的源发送端TCP对它进行确认。\n![这里写图片描述](http://img.blog.csdn.net/20171211195752810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n**客fin服务 -> 服ack客 -> 服fin客 -> 客ack服务**\n### 2.UDP\n参考文章：[用户数据报协议](https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE )\n\nUser Datagram Protocol，缩写为UDP，又称用户数据报文协议，是一个**简单的面向数据报的传输层协议**。\n\nUDP只提供数据的**不可靠传递**，它<u>一旦把应用程序发给网络层的数据发送出去，就不保留数据备份</u>（所以UDP有时候也被认为是不可靠的数据报协议）。\n\nUDP在IP数据报的头部仅仅加入了复用和数据校验（字段）。由于缺乏可靠性且属于非连接导向协议，UDP应用一般必须允许一定量的丢包、出错。流媒体（流技术）、即时多媒体游戏和IP电话（VoIP）一定就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（TCP协议）来代替UDP。\n### 3. 两者区别\n![这里写图片描述](http://img.blog.csdn.net/20171211200420262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)', 'TCP/IP协议是一个协议族。里面包括很多的协议。UDP只是其中的一个。之所以命名为TCP/IP协议，因为TCP/IP协议是两个很重要的协议，就用他两命名了。', '2018-03-12 14:31:40', '2018-03-26 11:32:50', null, '3866');
INSERT INTO `blog` VALUES ('168', '1', '1 2 25', '3 53 37 39 47', '1', 'javaWeb - 同源策略_ Jsonp', '<p><img src=\"http://upload-images.jianshu.io/upload_images/7460499-ce3597f977986dba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>博文内容总结自文章：<a href=\"http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514143&amp;idx=1&amp;sn=28ea209c00309e6b93d8d1f76032d7a4&amp;chksm=80d67cdcb7a1f5ca81d8d454a98af56d58b22f6058f100e21ff30e70867ea6e3e922a4f000bf&amp;mpshare=1&amp;scene=23&amp;srcid=1219hjtmL7SXftuOoe4cEI3A#rd\">浏览器家族的安全反击战</a></p>\n<h2 id=\"h2-u540Cu6E90u7B56u7565\"><a name=\"同源策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>同源策略</h2><p>同源是指{protocol,host,port} 这三个东西必须得一样！ 例如有这么一个网页： <a href=\"http://www.store.com/product/page.html，\">http://www.store.com/product/page.html，</a> 下面的表格列出了各种不同情况：<br><img src=\"http://img.blog.csdn.net/20180112100849763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h3 id=\"h3-u4F7Fu7528u540Cu6E90u7B56u7565u7684u539Fu56E0\"><a name=\"使用同源策略的原因\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用同源策略的原因</h3><ol>\n<li>Cookie失窃，非法网页通过javascript访问其他应用的服务器，获取到Cookie后伪装成用户进行非法操作。</li><li>通过iframe伪装form，将信息提交到恶意action，隐私数据提交到了不法网站，信息被盗取。<br><img src=\"http://img.blog.csdn.net/20180112100647979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></li></ol>\n<h3 id=\"h3-u540Cu6E90u7B56u7565u7684u9650u5236\"><a name=\"同源策略的限制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>同源策略的限制</h3><p><strong>有src属性的标签不受同源策略的影响</strong>。比如script、img、iframe、link。相当于浏览器发送get请求。原页面的js不能访问通过src加载的资源。</p>\n<p>如果两个网页的<strong>一级域名是相同的，他们可以共享cookie, 不过cookie的domain一定要设置为那个一级域名才可以</strong>，例如：<br>”document.cookie = ‘test=true;path=/;domain=store.com’”</p>\n<p>对于浏览器来说：除了DOM、Cookie、LocalStorage、XMLHttprequest（Ajax）会受到同源策略的限制外，浏览器加载的第三方插件也有各自的同源策略。例如：flash,java applet,silverlight等。</p>\n<p>既然服务器（domain）之间是互信的，那一个服务器(domain)可以<strong>设置一个白名单，里边列出它允许哪些服务器(domain)的AJAX请求</strong>。假设movie.com的白名单中有book.com， 那当属于book.com的JavaScript试图访问movie.com的时候，book.com先询问movie的白名单中是否有自己（是否允许自己访问），有就继续访问。<br><em>这个方法叫做Cross Origin Resource Sharing，简称CORS，只不过这个方法需要服务器的配合。</em></p>\n<h2 id=\"h2-jsonp\"><a name=\"jsonp\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>jsonp</h2><p>jsonp 的原理很简单，利用了【前端请求静态资源的时候不存在跨域问题】这个思路，但是只支持 get。既然这个方法叫 jsonp，后端数据一定要使用 json 数据。</p>\n<h3 id=\"h3--jquery-\"><a name=\"前端 jQuery 写法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前端 jQuery 写法</h3><pre><code class=\"lang-javascript\">   $.ajax({  \n            url:&quot;http://crossdomain.com/services.php&quot;,  \n            dataType:&#39;jsonp&#39;,  \n            data:&#39;&#39;,  \n            jsonp:&#39;callback&#39;,  \n            success:function(result) {  \n                for(var i in result) {  \n                    alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc.  \n                }  \n        },  \n            timeout:3000  \n    });\n</code></pre>\n<h3 id=\"h3--springmvc-\"><a name=\"后端 SpringMVC 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>后端 SpringMVC 配置</h3><pre><code class=\"lang-java\">@ControllerAdvice\npublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice {\n    public JsonpAdvice(){\n        // 这样如果请求中带 callback 参数，Spring 就知道这个是 jsonp 的请求了\n        super(&quot;callback&quot;);\n    }\n}\n</code></pre>\n<p>以上写法要求 SpringMVC 版本不低于 3.2 。</p>\n<h3 id=\"h3-u539Fu7406\"><a name=\"原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>原理</h3><p>首先在客户端注册一个callback方法（javaScript定义一个指定名字的回调方法）, 然后把callback的名字传给服务器。服务器先生成 json 数据。然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的回调函数的名字。</p>\n<p>最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。</p>\n<p>客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）</p>\n<h2 id=\"h2-cors\"><a name=\"CORS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CORS</h2><p>Cross-Origin Resource Sharing</p>\n<p>通过服务器端中转，例如你是来自book.com的， 现在想访问movie.com，那可以让那个book.com把请求转发给movie.com！利用了代理模式，book.com就是代理人。但在正式访问之前需要先发送预检请求（preflight request）确认自己能访问。</p>\n<p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个<strong>预检请求（preflight request），从而获知服务端是否允许该跨域请求</strong>。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。参考文章：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\">HTTP访问控制（CORS）</a></p>\n<p><img src=\"http://img.blog.csdn.net/20180112101924276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>CORS需要服务器的配合，CORS 支持以下浏览器，不过目前来看，浏览器的问题已经越来越不重要了。<br>Chrome 3+<br>Firefox 3.5+<br>Opera 12+<br>Safari 4+<br>Internet Explorer 8+</p>\n<h3 id=\"h3--jquery-\"><a name=\"前端 jQuery 写法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前端 jQuery 写法</h3><pre><code class=\"lang-jQuery\">$.ajax({\n    type: &quot;POST&quot;,\n    url: &quot;...url...&quot;,\n    dataType: &#39;json&#39;,\n    crossDomain: true,\n    xhrFields: {\n        withCredentials: true\n    },\n    data: {\n        name: &quot;name_from_frontend&quot;\n    },\n    success: function (response) {\n        console.log(response)// 返回的 json 数据\n        $(&quot;#response&quot;).val(JSON.stringify(response));\n    }\n});\n</code></pre>\n<p>crossDomain: true，这里代表使用跨域请求<br>xhrFields: {withCredentials: true}，这样配置就可以把 cookie 带过去了，不然 session 无法维护（cookie中保存了JSESSIONID），如果没有这个需求，也就不需要配置。</p>\n<hr>\n<p>&lt;center&gt;—-END—-&lt;/center&gt;</p>\n', '![](http://upload-images.jianshu.io/upload_images/7460499-ce3597f977986dba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n博文内容总结自文章：[浏览器家族的安全反击战](http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665514143&idx=1&sn=28ea209c00309e6b93d8d1f76032d7a4&chksm=80d67cdcb7a1f5ca81d8d454a98af56d58b22f6058f100e21ff30e70867ea6e3e922a4f000bf&mpshare=1&scene=23&srcid=1219hjtmL7SXftuOoe4cEI3A#rd )\n\n## 同源策略\n同源是指{protocol,host,port} 这三个东西必须得一样！ 例如有这么一个网页： http://www.store.com/product/page.html， 下面的表格列出了各种不同情况：\n![这里写图片描述](http://img.blog.csdn.net/20180112100849763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 使用同源策略的原因\n1. Cookie失窃，非法网页通过javascript访问其他应用的服务器，获取到Cookie后伪装成用户进行非法操作。\n2. 通过iframe伪装form，将信息提交到恶意action，隐私数据提交到了不法网站，信息被盗取。\n![这里写图片描述](http://img.blog.csdn.net/20180112100647979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 同源策略的限制\n**有src属性的标签不受同源策略的影响**。比如script、img、iframe、link。相当于浏览器发送get请求。原页面的js不能访问通过src加载的资源。\n\n如果两个网页的**一级域名是相同的，他们可以共享cookie, 不过cookie的domain一定要设置为那个一级域名才可以**，例如：\n”document.cookie = \'test=true;path=/;domain=store.com\'”\n\n对于浏览器来说：除了DOM、Cookie、LocalStorage、XMLHttprequest（Ajax）会受到同源策略的限制外，浏览器加载的第三方插件也有各自的同源策略。例如：flash,java applet,silverlight等。\n\n既然服务器（domain）之间是互信的，那一个服务器(domain)可以**设置一个白名单，里边列出它允许哪些服务器(domain)的AJAX请求**。假设movie.com的白名单中有book.com， 那当属于book.com的JavaScript试图访问movie.com的时候，book.com先询问movie的白名单中是否有自己（是否允许自己访问），有就继续访问。\n*这个方法叫做Cross Origin Resource Sharing，简称CORS，只不过这个方法需要服务器的配合。*\n\n## jsonp \njsonp 的原理很简单，利用了【前端请求静态资源的时候不存在跨域问题】这个思路，但是只支持 get。既然这个方法叫 jsonp，后端数据一定要使用 json 数据。\n### 前端 jQuery 写法\n```javascript\n   $.ajax({  \n	        url:\"http://crossdomain.com/services.php\",  \n	        dataType:\'jsonp\',  \n	        data:\'\',  \n	        jsonp:\'callback\',  \n	        success:function(result) {  \n	            for(var i in result) {  \n	                alert(i+\":\"+result[i]);//循环输出a:1,b:2,etc.  \n	            }  \n        },  \n	        timeout:3000  \n    });  \n\n```\n### 后端 SpringMVC 配置\n```java\n@ControllerAdvice\npublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice {\n    public JsonpAdvice(){\n        // 这样如果请求中带 callback 参数，Spring 就知道这个是 jsonp 的请求了\n        super(\"callback\");\n    }\n}\n```\n以上写法要求 SpringMVC 版本不低于 3.2 。\n### 原理\n首先在客户端注册一个callback方法（javaScript定义一个指定名字的回调方法）, 然后把callback的名字传给服务器。服务器先生成 json 数据。然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的回调函数的名字。\n\n最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。\n\n客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数）\n\n## CORS\nCross-Origin Resource Sharing\n\n通过服务器端中转，例如你是来自book.com的， 现在想访问movie.com，那可以让那个book.com把请求转发给movie.com！利用了代理模式，book.com就是代理人。但在正式访问之前需要先发送预检请求（preflight request）确认自己能访问。\n\n跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个**预检请求（preflight request），从而获知服务端是否允许该跨域请求**。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。参考文章：[HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n\n![这里写图片描述](http://img.blog.csdn.net/20180112101924276?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nCORS需要服务器的配合，CORS 支持以下浏览器，不过目前来看，浏览器的问题已经越来越不重要了。\nChrome 3+\nFirefox 3.5+\nOpera 12+\nSafari 4+\nInternet Explorer 8+\n### 前端 jQuery 写法\n```jQuery\n$.ajax({\n    type: \"POST\",\n    url: \"...url...\",\n    dataType: \'json\',\n    crossDomain: true,\n    xhrFields: {\n        withCredentials: true\n    },\n    data: {\n        name: \"name_from_frontend\"\n    },\n    success: function (response) {\n        console.log(response)// 返回的 json 数据\n        $(\"#response\").val(JSON.stringify(response));\n    }\n});\n\n```\ncrossDomain: true，这里代表使用跨域请求\nxhrFields: {withCredentials: true}，这样配置就可以把 cookie 带过去了，不然 session 无法维护（cookie中保存了JSESSIONID），如果没有这个需求，也就不需要配置。\n\n\n-----\n\n<center>---END---</center>', '首先在客户端注册一个callback方法（javaScript定义一个指定名字的回调方法）, 然后把callback的名字传给服务器。服务器先生成 json 数据。然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的回调函数的名字。', '2018-03-12 14:33:12', '2018-03-26 10:04:31', null, '5703');
INSERT INTO `blog` VALUES ('169', '1', '1', '', '1', '时间复杂度', '<p><img src=\"http://upload-images.jianshu.io/upload_images/7460499-1cae50e7ad4dfb10.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"h3--\"><a name=\"何谓算法？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>何谓算法？</h3><p>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着<strong>用系统的方法描述解决问题的策略机制</strong>。对于同一个问题的解决，可能会存在着不同的算法，为了衡量一个算法的优劣，提出了&lt;u&gt;空间复杂度与时间复杂度&lt;/u&gt;这两个概念。</p>\n<p>一个算法是由<strong>控制结构（顺序、分支和循环3种）</strong>和<strong>原操作（指固有数据类型的操作）</strong>构成的，则算法时间取决于&lt;u&gt;两者的综合效果&lt;/u&gt;。为了便于比较同一个问题的不同算法，通常的做法是：</p>\n<p>&lt;p&gt;从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。&lt;/p&gt;</p>\n<h4 id=\"h4-u65F6u95F4u590Du6742u5EA6\"><a name=\"时间复杂度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>时间复杂度</h4><p>参考文章：<a href=\"http://blog.csdn.net/zolalad/article/details/11848739\">算法的时间复杂度和空间复杂度-总结</a><br>时间复杂度，又称时间频度，即<strong>一个算法执行所耗费的时间</strong>。</p>\n<p>&lt;u&gt;一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。&lt;/u&gt;一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)</p>\n<p>n称为<strong>问题的规模</strong>，当n不断变化时，时间频度T(n)也会不断变化。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，&lt;i&gt; 若有某个辅助函数f(n),使得当n趋近于无穷大时，*T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。&lt;/i&gt;</p>\n<p>算法中语句执行次数为一个常数，则时间复杂度为O(1)。常见的时间复杂度有：&lt;p&gt;&lt;b&gt;常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(n log2n),平方阶O(n2)，立方阶O(n3),…。&lt;/b&gt;&lt;/p&gt;<br>&lt;i&gt;&lt;b&gt;Log&lt;/b&gt;&lt;u&gt;2&lt;/u&gt;&lt;b&gt;8&lt;/b&gt;：2为底N的对数，即2的几次方等于8，值为3&lt;/i&gt;<br>&lt;br&gt;<br>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(n log2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)<br>即：常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 立方阶 &lt; … &lt; 指数阶 &lt; 阶乘<br><img src=\"http://img.blog.csdn.net/20171212203622006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"h4-u6C42u89E3u7B97u6CD5u7684u65F6u95F4u590Du6742u5EA6u7684u5177u4F53u6B65u9AA4\"><a name=\"求解算法的时间复杂度的具体步骤\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>求解算法的时间复杂度的具体步骤</h4><ol>\n<li>找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。</li><li>计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。</li><li>用大Ο记号表示算法的时间性能。</li></ol>\n<p>如：<br><img src=\"http://img.blog.csdn.net/20171212203652475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n1+n2+n3)=Ο(n3)。</p>\n<p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法。</p>\n<p>&lt;i&gt;指数函数：y=ax，对数函数：y=logax，幂函数：y=xa<br>x为变量，a为常量&lt;/i&gt;</p>\n', '![](http://upload-images.jianshu.io/upload_images/7460499-1cae50e7ad4dfb10.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 何谓算法？\n算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着**用系统的方法描述解决问题的策略机制**。对于同一个问题的解决，可能会存在着不同的算法，为了衡量一个算法的优劣，提出了<u>空间复杂度与时间复杂度</u>这两个概念。\n\n一个算法是由**控制结构（顺序、分支和循环3种）**和**原操作（指固有数据类型的操作）**构成的，则算法时间取决于<u>两者的综合效果</u>。为了便于比较同一个问题的不同算法，通常的做法是：\n<p>从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。</p>\n#### 时间复杂度\n参考文章：[算法的时间复杂度和空间复杂度-总结](http://blog.csdn.net/zolalad/article/details/11848739 )\n时间复杂度，又称时间频度，即**一个算法执行所耗费的时间**。\n\n<u>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。</u>一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)\n\nn称为**问题的规模**，当n不断变化时，时间频度T(n)也会不断变化。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，<i> 若有某个辅助函数f(n),使得当n趋近于无穷大时，*T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。</i>\n\n算法中语句执行次数为一个常数，则时间复杂度为O(1)。常见的时间复杂度有：<p><b>常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(n log2n),平方阶O(n2)，立方阶O(n3),...。</b></p>\n<i><b>Log</b><u>2</u><b>8</b>：2为底N的对数，即2的几次方等于8，值为3</i>\n<br>\n常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(n log2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)\n即：常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 立方阶 < … < 指数阶 < 阶乘\n![这里写图片描述](http://img.blog.csdn.net/20171212203622006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n#### 求解算法的时间复杂度的具体步骤\n\n1.	找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。\n2.	计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。\n3.	用大Ο记号表示算法的时间性能。\n\n如： \n![这里写图片描述](http://img.blog.csdn.net/20171212203652475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n1+n2+n3)=Ο(n3)。\n\nΟ(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法。\n\n<i>指数函数：y=ax，对数函数：y=logax，幂函数：y=xa\nx为变量，a为常量</i>\n', '算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。对于同一个问题的解决，可能会存在着不同的算法，为了衡量一个算法的优劣。', '2018-03-12 14:35:22', '2018-03-26 11:33:16', null, '2743');
INSERT INTO `blog` VALUES ('170', '1', '1', '', '1', '算法求解步骤', '<h3 id=\"h3--\"><a name=\"何谓算法？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>何谓算法？</h3><p>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着<strong>用系统的方法描述解决问题的策略机制</strong>。对于同一个问题的解决，可能会存在着不同的算法，为了衡量一个算法的优劣，提出了&lt;u&gt;空间复杂度与时间复杂度&lt;/u&gt;这两个概念。<br><img src=\"http://img.blog.csdn.net/20171212203652475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>一个算法是由<strong>控制结构（顺序、分支和循环3种）</strong>和<strong>原操作（指固有数据类型的操作）</strong>构成的，则算法时间取决于&lt;u&gt;两者的综合效果&lt;/u&gt;。为了便于比较同一个问题的不同算法，通常的做法是：</p>\n<p>&lt;p&gt;从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。&lt;/p&gt;</p>\n<h4 id=\"h4-u65F6u95F4u590Du6742u5EA6\"><a name=\"时间复杂度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>时间复杂度</h4><p>参考文章：<a href=\"http://blog.csdn.net/zolalad/article/details/11848739\">算法的时间复杂度和空间复杂度-总结</a><br>时间复杂度，又称时间频度，即<strong>一个算法执行所耗费的时间</strong>。</p>\n<p>&lt;u&gt;一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。&lt;/u&gt;一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)</p>\n<p>n称为<strong>问题的规模</strong>，当n不断变化时，时间频度T(n)也会不断变化。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，&lt;i&gt; 若有某个辅助函数f(n),使得当n趋近于无穷大时，*T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。&lt;/i&gt;</p>\n<p>算法中语句执行次数为一个常数，则时间复杂度为O(1)。常见的时间复杂度有：&lt;p&gt;&lt;b&gt;常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(n log2n),平方阶O(n2)，立方阶O(n3),…。&lt;/b&gt;&lt;/p&gt;<br>&lt;i&gt;&lt;b&gt;Log&lt;/b&gt;&lt;u&gt;2&lt;/u&gt;&lt;b&gt;8&lt;/b&gt;：2为底N的对数，即2的几次方等于8，值为3&lt;/i&gt;<br>&lt;br&gt;<br>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(n log2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)<br>即：常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 立方阶 &lt; … &lt; 指数阶 &lt; 阶乘<br><img src=\"http://img.blog.csdn.net/20171212203622006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4 id=\"h4-u6C42u89E3u7B97u6CD5u7684u65F6u95F4u590Du6742u5EA6u7684u5177u4F53u6B65u9AA4\"><a name=\"求解算法的时间复杂度的具体步骤\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>求解算法的时间复杂度的具体步骤</h4><ol>\n<li>找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。</li><li>计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。</li><li>用大Ο记号表示算法的时间性能。</li></ol>\n<p>如：<br>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n1+n2+n3)=Ο(n3)。</p>\n<p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法。</p>\n<p>&lt;i&gt;指数函数：y=ax，对数函数：y=logax，幂函数：y=xa<br>x为变量，a为常量&lt;/i&gt;</p>\n', '### 何谓算法？\n算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着**用系统的方法描述解决问题的策略机制**。对于同一个问题的解决，可能会存在着不同的算法，为了衡量一个算法的优劣，提出了<u>空间复杂度与时间复杂度</u>这两个概念。\n![这里写图片描述](http://img.blog.csdn.net/20171212203652475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n一个算法是由**控制结构（顺序、分支和循环3种）**和**原操作（指固有数据类型的操作）**构成的，则算法时间取决于<u>两者的综合效果</u>。为了便于比较同一个问题的不同算法，通常的做法是：\n<p>从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。</p>\n#### 时间复杂度\n参考文章：[算法的时间复杂度和空间复杂度-总结](http://blog.csdn.net/zolalad/article/details/11848739 )\n时间复杂度，又称时间频度，即**一个算法执行所耗费的时间**。\n\n<u>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。</u>一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)\n\nn称为**问题的规模**，当n不断变化时，时间频度T(n)也会不断变化。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，<i> 若有某个辅助函数f(n),使得当n趋近于无穷大时，*T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。</i>\n\n算法中语句执行次数为一个常数，则时间复杂度为O(1)。常见的时间复杂度有：<p><b>常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(n log2n),平方阶O(n2)，立方阶O(n3),...。</b></p>\n<i><b>Log</b><u>2</u><b>8</b>：2为底N的对数，即2的几次方等于8，值为3</i>\n<br>\n常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(n log2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)\n即：常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 立方阶 < … < 指数阶 < 阶乘\n![这里写图片描述](http://img.blog.csdn.net/20171212203622006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n#### 求解算法的时间复杂度的具体步骤\n\n1.	找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。\n2.	计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。\n3.	用大Ο记号表示算法的时间性能。\n\n如： \n第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n1+n2+n3)=Ο(n3)。\n\nΟ(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法。\n\n<i>指数函数：y=ax，对数函数：y=logax，幂函数：y=xa\nx为变量，a为常量</i>\n', '找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。\n计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。\n用大Ο记号表示算法的时间性能。', '2018-03-12 14:54:58', '2018-03-26 09:44:01', null, '2743');
INSERT INTO `blog` VALUES ('171', '24', '', '', '1', 'java 集合 linkedList', '<p>java 集合 2 - LinkedList</p>\n<p>参考文章：<a href=\"http://www.cnblogs.com/xrq730/p/5005347.html\">图解集合2：LinkedList</a></p>\n<p>LinkedList是基于<a href=\"https://baike.baidu.com/item/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2968731?fr=aladdin\">双向链表</a>实现的。<br>|特性||<br>|——|——-|<br>|是否存取null值|可以|<br>|元素是否可以重复|可以|<br>|是否有序|有序|<br>|是否线程安全|不安全|</p>\n<p>接下来直接通过源码（<strong>jdk1.8</strong>）分析。</p>\n<h3 id=\"h3-u7ED3u70B9u5B9Au4E49\"><a name=\"结点定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>结点定义</h3><pre><code class=\"lang-java\">\n    private static class Node&lt;E&gt; {\n        E item;\n        Node&lt;E&gt; next;\n        Node&lt;E&gt; prev;\n\n        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n</code></pre>\n<p>可见，对于每一个结点，可以通过prev找到它的直接前驱，通过next找到其后继。</p>\n<h3 id=\"h3--\"><a name=\"头，尾结点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>头，尾结点</h3><pre><code class=\"lang-java\">    /**\n     * Pointer to first node.\n     * Invariant: (first == null &amp;&amp; last == null) ||\n     *            (first.prev == null &amp;&amp; first.item != null)\n     */\n    transient Node&lt;E&gt; first;\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null &amp;&amp; last == null) ||\n     *            (last.next == null &amp;&amp; last.item != null)\n     */\n    transient Node&lt;E&gt; last;\n</code></pre>\n<p>作为双向链表，链表头的前驱为链表尾，链表尾的后继为链表头，first和last满足如下关系：<br>first不为空，且链表尾为空，那么链表只有一个元素，保存于链表头；last不为空，且链表头为空，那么链表只有一个元素，保存于链表尾。</p>\n<h3 id=\"h3-add-\"><a name=\"add方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>add方法</h3><pre><code class=\"lang-java\">    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n\n    public void add(int index, E element) {\n        checkPositionIndex(index);\n\n        if (index == size)\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n</code></pre>\n<ul>\n<li>一个参数的add方法实际调用了linkLast方法，linkLast方法。</li><li>两个参数的add方法先检查下标是否越界，之后如果下标（从0开始）为当前链表的长度（size从1开始），那么就是新增元素于链表尾，否则调用linkbefore插入元素。</li></ul>\n<h4 id=\"h4-linklast-\"><a name=\"linkLast方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>linkLast方法</h4><pre><code class=\"lang-java\">    /**\n     * Links e as last element.\n     */\n    void linkLast(E e) {\n        final Node&lt;E&gt; l = last;\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n</code></pre>\n<p>可见linkLast方法会将新的结点进行构造，然后替换原来的尾结点，如果原来的尾结点为空，那意味着链表还没有元素（有一个元素时头尾就都不为null），此时构造的就是第一个元素，使头尾都指向同一元素（该元素的前驱和后继都为null），如果原来的尾结点已经存在，那么将原来的尾结点的后继指向新的尾结点即可。</p>\n<h4 id=\"h4-linkbefore-\"><a name=\"linkBefore方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>linkBefore方法</h4><pre><code class=\"lang-java\">    /**\n     * Inserts element e before non-null Node succ.\n     */\n    void linkBefore(E e, Node&lt;E&gt; succ) {\n        // assert succ != null;\n        final Node&lt;E&gt; pred = succ.prev;\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n</code></pre>\n<p>这里对应succ参数的定位发生在node方法中：</p>\n<h4 id=\"h4-node-\"><a name=\"node方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>node方法</h4><pre><code class=\"lang-java\">    /**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node&lt;E&gt; node(int index) {\n        // assert isElementIndex(index);\n\n        if (index &lt; (size &gt;&gt; 1)) {\n            Node&lt;E&gt; x = first;\n            for (int i = 0; i &lt; index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node&lt;E&gt; x = last;\n            for (int i = size - 1; i &gt; index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n</code></pre>\n<p>结合上面双参数的add方法，可见该方法首先会判断新插入的点在链表中的大体位置（前一半还是后一半），然后从前往后或从后往前定位到指定下标的点并返回。</p>\n<p>再回头看linkBefore方法，构建新节点，修改被插入结点的前驱，被插入结点的原前驱的后继。</p>\n<h3 id=\"h3-get-\"><a name=\"get方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>get方法</h3><pre><code class=\"lang-java\">public E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n</code></pre>\n<p>get方法首先会检查下标，然后通过node方法定位目标结点，取出值返回。</p>\n<h3 id=\"h3-indexof-\"><a name=\"indexOf方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>indexOf方法</h3><pre><code class=\"lang-java\"> public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node&lt;E&gt; x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n</code></pre>\n<p>该方法用于查找指定元素的下标，可见该方法会对目标元素是否为null采用不同的搜索方式，没找到则返回-1。</p>\n<hr>\n<p>&lt;center&gt;—-END—-&lt;/center&gt;</p>\n', 'java 集合 2 - LinkedList\n\n参考文章：[图解集合2：LinkedList](http://www.cnblogs.com/xrq730/p/5005347.html)\n\nLinkedList是基于[双向链表](https://baike.baidu.com/item/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2968731?fr=aladdin)实现的。\n|特性||\n|----|-----|\n|是否存取null值|可以|\n|元素是否可以重复|可以|\n|是否有序|有序|\n|是否线程安全|不安全|\n\n接下来直接通过源码（**jdk1.8**）分析。\n\n### 结点定义\n```java\n\n    private static class Node<E> {\n        E item;\n        Node<E> next;\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n可见，对于每一个结点，可以通过prev找到它的直接前驱，通过next找到其后继。\n### 头，尾结点\n```java\n    /**\n     * Pointer to first node.\n     * Invariant: (first == null && last == null) ||\n     *            (first.prev == null && first.item != null)\n     */\n    transient Node<E> first;\n\n    /**\n     * Pointer to last node.\n     * Invariant: (first == null && last == null) ||\n     *            (last.next == null && last.item != null)\n     */\n    transient Node<E> last;\n```\n作为双向链表，链表头的前驱为链表尾，链表尾的后继为链表头，first和last满足如下关系：\nfirst不为空，且链表尾为空，那么链表只有一个元素，保存于链表头；last不为空，且链表头为空，那么链表只有一个元素，保存于链表尾。\n\n### add方法\n```java\n    public boolean add(E e) {\n        linkLast(e);\n        return true;\n    }\n    \n    public void add(int index, E element) {\n        checkPositionIndex(index);\n\n        if (index == size)\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n``` \n- 一个参数的add方法实际调用了linkLast方法，linkLast方法。\n- 两个参数的add方法先检查下标是否越界，之后如果下标（从0开始）为当前链表的长度（size从1开始），那么就是新增元素于链表尾，否则调用linkbefore插入元素。\n\n#### linkLast方法\n```java\n    /**\n     * Links e as last element.\n     */\n    void linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n可见linkLast方法会将新的结点进行构造，然后替换原来的尾结点，如果原来的尾结点为空，那意味着链表还没有元素（有一个元素时头尾就都不为null），此时构造的就是第一个元素，使头尾都指向同一元素（该元素的前驱和后继都为null），如果原来的尾结点已经存在，那么将原来的尾结点的后继指向新的尾结点即可。\n\n#### linkBefore方法\n```java\n    /**\n     * Inserts element e before non-null Node succ.\n     */\n    void linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n```\n这里对应succ参数的定位发生在node方法中：\n#### node方法\n```java\n    /**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n```\n结合上面双参数的add方法，可见该方法首先会判断新插入的点在链表中的大体位置（前一半还是后一半），然后从前往后或从后往前定位到指定下标的点并返回。\n\n再回头看linkBefore方法，构建新节点，修改被插入结点的前驱，被插入结点的原前驱的后继。\n\n### get方法\n```java\npublic E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n```\nget方法首先会检查下标，然后通过node方法定位目标结点，取出值返回。\n\n### indexOf方法\n```java\n public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n```\n该方法用于查找指定元素的下标，可见该方法会对目标元素是否为null采用不同的搜索方式，没找到则返回-1。\n\n-----\n\n<center>---END---</center>', '作为双向链表，链表头的前驱为链表尾，链表尾的后继为链表头，first和last满足如下关系：\nfirst不为空，且链表尾为空，那么链表只有一个元素，保存于链表头；last不为空，且链表头为空，那么链表只有一个元素，保存于链表尾。', '2018-03-14 16:46:31', '2018-03-14 16:46:31', null, '5440');
INSERT INTO `blog` VALUES ('172', '24', '35', '', '1', 'java 集合 HashSet', '<h2 id=\"h2-hashset\"><a name=\"HashSet\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HashSet</h2><p>参考文章：<a href=\"http://www.importnew.com/6931.html\">HashMap和HashSet的区别</a></p>\n<p>HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。</p>\n<h3 id=\"h3-u6784u9020u5668\"><a name=\"构造器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>构造器</h3><p>HashSet内部用于存储数据的实体为HashMap，构造器中会对HashMap实例map进行初始化。</p>\n<pre><code class=\"lang-java\">    private transient HashMap&lt;E,Object&gt; map;\n\n    public HashSet() {\n        map = new HashMap&lt;&gt;();\n    }\n\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap&lt;&gt;(initialCapacity, loadFactor);\n    }\n\n    public HashSet(int initialCapacity) {\n        map = new HashMap&lt;&gt;(initialCapacity);\n    }\n</code></pre>\n<h3 id=\"h3-add-\"><a name=\"add方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>add方法</h3><pre><code class=\"lang-java\">\n    // Dummy value to associate with an Object in the backing Map\n    // 与后台映射中的对象关联的虚拟值\n    private static final Object PRESENT = new Object();\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n</code></pre>\n<p>可见向HashSet中添加值时其实是将新值作为map的键存到HashMap中，而map所有键的值都为PRESENT，PRESENT是一个虚拟的值（无用的值）。</p>\n<p>从这里就可以看出<strong>HashSet保证元素唯一的方法是借助HashMap的键不重复</strong>这一特性完成的。这也就解释了为什么存到HashSet中的元素要覆写其equals和hashCode方法（HashMap对于键的重复判定是通过hashCode和equals方法）。</p>\n<h3 id=\"h3-iterator\"><a name=\"iterator\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>iterator</h3><pre><code class=\"lang-java\">    public Iterator&lt;E&gt; iterator() {\n        return map.keySet().iterator();\n    }\n</code></pre>\n<p>HashSet没有get方法来获得元素，只能通过迭代器或者toArray方法获得所有元素，而Iterator方法将获得map键集的迭代器。</p>\n<p>此外可通过contains方法判断set中是否存入了目标元素。</p>\n<hr>\n<p>&lt;center&gt;—-END—-&lt;/center&gt;\n</p>\n', '## HashSet\n参考文章：[HashMap和HashSet的区别](http://www.importnew.com/6931.html)\n\nHashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。\n\n### 构造器\nHashSet内部用于存储数据的实体为HashMap，构造器中会对HashMap实例map进行初始化。\n```java\n    private transient HashMap<E,Object> map;\n\n    public HashSet() {\n        map = new HashMap<>();\n    }\n    \n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap<>(initialCapacity, loadFactor);\n    }\n    \n    public HashSet(int initialCapacity) {\n        map = new HashMap<>(initialCapacity);\n    }\n```\n\n### add方法\n```java\n\n    // Dummy value to associate with an Object in the backing Map\n    // 与后台映射中的对象关联的虚拟值\n    private static final Object PRESENT = new Object();\n \n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n```\n可见向HashSet中添加值时其实是将新值作为map的键存到HashMap中，而map所有键的值都为PRESENT，PRESENT是一个虚拟的值（无用的值）。\n\n从这里就可以看出**HashSet保证元素唯一的方法是借助HashMap的键不重复**这一特性完成的。这也就解释了为什么存到HashSet中的元素要覆写其equals和hashCode方法（HashMap对于键的重复判定是通过hashCode和equals方法）。\n\n### iterator\n```java\n    public Iterator<E> iterator() {\n        return map.keySet().iterator();\n    }\n```\nHashSet没有get方法来获得元素，只能通过迭代器或者toArray方法获得所有元素，而Iterator方法将获得map键集的迭代器。\n\n此外可通过contains方法判断set中是否存入了目标元素。\n\n---\n\n<center>---END---</center>\n', '可见向HashSet中添加值时其实是将新值作为map的键存到HashMap中，而map所有键的值都为PRESENT，PRESENT是一个虚拟的值（无用的值）。', '2018-03-14 16:47:37', '2018-03-14 16:47:37', null, '2022');
INSERT INTO `blog` VALUES ('173', '25', '', '', '1', 'LinkedHashMap', '<p>参考文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651479784&amp;idx=1&amp;sn=929e81473146994b15404f4f4d15748e&amp;chksm=bd2532978a52bb81947307b772b39d89566d84a35f6fe55956bb516a357dc92a27e3a498c64c&amp;mpshare=1&amp;scene=23&amp;srcid=0116WyUGZhbE9kiPwYGd0x42#rd\">Java LinkedHashMap 源码解析</a>，<a href=\"http://www.cnblogs.com/xrq730/p/5052323.html\">图解集合6：LinkedHashMap</a></p>\n<p>基于 jdk 1.8 分析源码</p>\n<p>LinkedHashMap允许一个null键和多个null值，有序，线程不安全。</p>\n<p>LinkedHashMap直接使用父类HashMap的<strong>数组&amp;链表</strong>结构保存数据，同时自己又采用了<strong>环型双向链表</strong>来维护元素顺序。</p>\n<p>LinkedHashMap提供了两种形式的顺序：<br><strong>访问顺序（access order）</strong>：非常实用，可以使用这种顺序实现LRU（Least Recently Used）缓存（详见get方法解析）<br><strong>插入顺序（insertion orde）</strong>：元素的插入顺序（同一key的多次插入不会影响其顺序，详见newNode方法解析）</p>\n<p>先来看看这两种顺序是的效果：</p>\n<h3 id=\"h3-u8BBFu95EEu987Au5E8F\"><a name=\"访问顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>访问顺序</h3><p><img src=\"http://img.blog.csdn.net/20180116141254497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>可见通过get方法访问了Map中的元素，之后遍历值集合时遍历顺序受到了访问操作的影响，即“最近”被访问的元素排在值集合（即链表）的最前面。</p>\n<p>这样在实现LRU算法时就能很方便的找到最近最少被使用的元素，即链表的头元素。</p>\n<h3 id=\"h3-u63D2u5165u987Au5E8F\"><a name=\"插入顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>插入顺序</h3><p><img src=\"http://img.blog.csdn.net/20180116141752223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>默认采用的就是“插入顺序”。遍历时就会以插入顺序遍历。</p>\n<h2 id=\"h2-entry\"><a name=\"Entry\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Entry</h2><pre><code class=\"lang-java\">    /**\n     * HashMap.Node subclass for normal LinkedHashMap entries.\n     */\n    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {\n        Entry&lt;K,V&gt; before, after;\n        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {\n            super(hash, key, value, next);\n        }\n    }\n</code></pre>\n<p>LinkedHashMap直接使用了HashMap的数据结构来保存元素，不同的是相比HashMap的Entry增加了before和after成员，这两个成员用于维护元素的顺序。</p>\n<h2 id=\"h2-u6784u9020u5668\"><a name=\"构造器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>构造器</h2><pre><code class=\"lang-java\">    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(int initialCapacity,\n                         float loadFactor,\n                         boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n</code></pre>\n<p>LinkedHashMap继承自HashMap，所以构造其中的super调用了父类HashMap的构造器。</p>\n<p>要想使用“访问顺序”形式时只能通过调用三个参数的构造器创建实例。</p>\n<h2 id=\"h2-put\"><a name=\"put\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>put</h2><p>LinkedHashMap并未重写HashMap的put方法，即直接调用了HashMap的put方法，也就是说LinkedHashMap插入元素时并未采取额外措施以实现其“有序”功能，那么该功能是在哪里实现的呢？</p>\n<h2 id=\"h2-get\"><a name=\"get\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>get</h2><pre><code class=\"lang-java\">    public V get(Object key) {\n        Node&lt;K,V&gt; e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n</code></pre>\n<p>get方法用于获得指定键对应的值（如果存在的话）。</p>\n<p>注意<code>if(accessOrder) afterNodeAccess(e);</code>一句，上面提到LinkedHashMap的“有序”有两种体现形式，一种为“插入顺序”，一种为“访问顺序”，而<code>accessOrder</code>成员就是“访问顺序”形式的启用开关。</p>\n<h2 id=\"h2-afternodeaccess\"><a name=\"afterNodeAccess\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>afterNodeAccess</h2><pre><code class=\"lang-java\">    void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last\n        LinkedHashMap.Entry&lt;K,V&gt; last;\n        if (accessOrder &amp;&amp; (last = tail) != e) {\n            LinkedHashMap.Entry&lt;K,V&gt; p =\n                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null) \n                head = a;\n            else \n                b.after = a; \n            if (a != null) \n                a.before = b;\n            else \n                last = b; \n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n    }\n</code></pre>\n<p>如果开启了“访问顺序”的形式（创建实例时使用三个参数的构造器），并且当前访问的元素不是链表的尾结点，那么就会将当前访问结点变换为尾结点。</p>\n<p>即最外层if条件成立，之后将当前访问结点强转为记录有前驱后继的LinkedHashMap专用结点，这里需要注意：参看上面的put方法我们知道put方法直接调用了HashMap的put方法，那么按理插入的结点类型也是HashMap.Node类型的，怎么能够强转为LinkedHashMap.Entry类型呢？</p>\n<p><strong>原因是这样的</strong>：参考HashMap源码可以知道，put方法内部调用了putVal，putVal中创建新节点调用的是<code>newNode</code>方法（而不是直接 new HashMap.Node），而LinkedHashMap重写了这个方法：</p>\n<p>HashMap#newNode</p>\n<pre><code class=\"lang-java\">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {\n        return new Node&lt;&gt;(hash, key, value, next);\n    }\n</code></pre>\n<p>LinkedHashMap#newNode</p>\n<pre><code class=\"lang-java\">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {\n        LinkedHashMap.Entry&lt;K,V&gt; p =\n            new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);\n        linkNodeLast(p);\n        return p;\n    }\n</code></pre>\n<p>所以这里强转就不会出现<code>ClassCastException</code>。</p>\n<p>之后的步骤就是将当前访问结点变换为尾结点的过程了（有点复杂，没理清）。</p>\n<h2 id=\"h2-newnode\"><a name=\"newNode\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>newNode</h2><pre><code class=\"lang-java\">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {\n        LinkedHashMap.Entry&lt;K,V&gt; p =\n            new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);\n        linkNodeLast(p);\n        return p;\n    }\n</code></pre>\n<p>上面已经说了一下newNode方法的，除了用于创建新元素以外，在LinkedHashMap中，newNode方法还额外做了一件事情：将当前元素链接到链表尾，即创建LinkedHashMap专用的LinkedHashMap.Entry，构造该节点的前驱和后继以维护其“插入顺序”。对应linkNodeLast方法。</p>\n<pre><code class=\"lang-java\"> private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {\n        LinkedHashMap.Entry&lt;K,V&gt; last = tail;\n        tail = p;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n    }\n</code></pre>\n<p>如果尾结点为空，这意味着LinkedHashMap中没有元素，那么新元素就是链表头（<code>head=p</code>），同时链表尾元素也指向它（<code>tail=p</code>）；否则将链表尾元素替换为新的元素（<code>p.before=last;last.after=p;</code>）。</p>\n<hr>\n<p>&lt;center&gt;—-END—-&lt;/center&gt;</p>\n', '参考文章：[Java LinkedHashMap 源码解析](https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651479784&idx=1&sn=929e81473146994b15404f4f4d15748e&chksm=bd2532978a52bb81947307b772b39d89566d84a35f6fe55956bb516a357dc92a27e3a498c64c&mpshare=1&scene=23&srcid=0116WyUGZhbE9kiPwYGd0x42#rd)，[图解集合6：LinkedHashMap](http://www.cnblogs.com/xrq730/p/5052323.html)\n\n基于 jdk 1.8 分析源码\n\nLinkedHashMap允许一个null键和多个null值，有序，线程不安全。\n\nLinkedHashMap直接使用父类HashMap的**数组&链表**结构保存数据，同时自己又采用了**环型双向链表**来维护元素顺序。\n\nLinkedHashMap提供了两种形式的顺序：\n**访问顺序（access order）**：非常实用，可以使用这种顺序实现LRU（Least Recently Used）缓存（详见get方法解析）\n**插入顺序（insertion orde）**：元素的插入顺序（同一key的多次插入不会影响其顺序，详见newNode方法解析）\n\n先来看看这两种顺序是的效果：\n### 访问顺序\n![这里写图片描述](http://img.blog.csdn.net/20180116141254497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可见通过get方法访问了Map中的元素，之后遍历值集合时遍历顺序受到了访问操作的影响，即“最近”被访问的元素排在值集合（即链表）的最前面。\n\n这样在实现LRU算法时就能很方便的找到最近最少被使用的元素，即链表的头元素。\n\n### 插入顺序\n![这里写图片描述](http://img.blog.csdn.net/20180116141752223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n默认采用的就是“插入顺序”。遍历时就会以插入顺序遍历。\n\n## Entry\n```java\n    /**\n     * HashMap.Node subclass for normal LinkedHashMap entries.\n     */\n    static class Entry<K,V> extends HashMap.Node<K,V> {\n        Entry<K,V> before, after;\n        Entry(int hash, K key, V value, Node<K,V> next) {\n            super(hash, key, value, next);\n        }\n    }\n```\nLinkedHashMap直接使用了HashMap的数据结构来保存元素，不同的是相比HashMap的Entry增加了before和after成员，这两个成员用于维护元素的顺序。\n\n## 构造器\n```java\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n    \n    public LinkedHashMap(int initialCapacity,\n                         float loadFactor,\n                         boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n```\nLinkedHashMap继承自HashMap，所以构造其中的super调用了父类HashMap的构造器。\n\n要想使用“访问顺序”形式时只能通过调用三个参数的构造器创建实例。\n\n## put\nLinkedHashMap并未重写HashMap的put方法，即直接调用了HashMap的put方法，也就是说LinkedHashMap插入元素时并未采取额外措施以实现其“有序”功能，那么该功能是在哪里实现的呢？\n\n## get\n```java\n    public V get(Object key) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n```\nget方法用于获得指定键对应的值（如果存在的话）。\n\n注意`if(accessOrder) afterNodeAccess(e);`一句，上面提到LinkedHashMap的“有序”有两种体现形式，一种为“插入顺序”，一种为“访问顺序”，而`accessOrder`成员就是“访问顺序”形式的启用开关。\n\n## afterNodeAccess\n```java\n    void afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMap.Entry<K,V> last;\n        if (accessOrder && (last = tail) != e) {\n            LinkedHashMap.Entry<K,V> p =\n                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null) \n                head = a;\n            else \n                b.after = a; \n            if (a != null) \n                a.before = b;\n            else \n                last = b; \n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n    }\n```\n如果开启了“访问顺序”的形式（创建实例时使用三个参数的构造器），并且当前访问的元素不是链表的尾结点，那么就会将当前访问结点变换为尾结点。\n\n即最外层if条件成立，之后将当前访问结点强转为记录有前驱后继的LinkedHashMap专用结点，这里需要注意：参看上面的put方法我们知道put方法直接调用了HashMap的put方法，那么按理插入的结点类型也是HashMap.Node类型的，怎么能够强转为LinkedHashMap.Entry类型呢？\n\n**原因是这样的**：参考HashMap源码可以知道，put方法内部调用了putVal，putVal中创建新节点调用的是`newNode`方法（而不是直接 new HashMap.Node），而LinkedHashMap重写了这个方法：\n\nHashMap#newNode\n```java\n    Node<K,V> newNode(int hash, K key, V value, Node<K,V> next) {\n        return new Node<>(hash, key, value, next);\n    }\n```\n\nLinkedHashMap#newNode\n```java\n    Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n        LinkedHashMap.Entry<K,V> p =\n            new LinkedHashMap.Entry<K,V>(hash, key, value, e);\n        linkNodeLast(p);\n        return p;\n    }\n```\n所以这里强转就不会出现`ClassCastException`。\n\n之后的步骤就是将当前访问结点变换为尾结点的过程了（有点复杂，没理清）。\n\n## newNode\n```java\n    Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n        LinkedHashMap.Entry<K,V> p =\n            new LinkedHashMap.Entry<K,V>(hash, key, value, e);\n        linkNodeLast(p);\n        return p;\n    }\n```\n上面已经说了一下newNode方法的，除了用于创建新元素以外，在LinkedHashMap中，newNode方法还额外做了一件事情：将当前元素链接到链表尾，即创建LinkedHashMap专用的LinkedHashMap.Entry，构造该节点的前驱和后继以维护其“插入顺序”。对应linkNodeLast方法。\n\n```java\n private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n        LinkedHashMap.Entry<K,V> last = tail;\n        tail = p;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n    }\n```\n如果尾结点为空，这意味着LinkedHashMap中没有元素，那么新元素就是链表头（`head=p`），同时链表尾元素也指向它（`tail=p`）；否则将链表尾元素替换为新的元素（`p.before=last;last.after=p;`）。\n\n----\n\n<center>---END---</center>', '上面已经说了一下newNode方法的，除了用于创建新元素以外，在LinkedHashMap中，newNode方法还额外做了一件事情：将当前元素链接到链表尾，即创建LinkedHashMap专用的LinkedHashMap.Entry，构造该节点的前驱和后继以维护其“插入顺序”。对应linkNodeLast方法。', '2018-03-14 17:03:00', '2018-03-14 17:03:00', null, '6653');
INSERT INTO `blog` VALUES ('174', '25', '', '', '1', 'before和after成员', '<p>参考文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651479784&amp;idx=1&amp;sn=929e81473146994b15404f4f4d15748e&amp;chksm=bd2532978a52bb81947307b772b39d89566d84a35f6fe55956bb516a357dc92a27e3a498c64c&amp;mpshare=1&amp;scene=23&amp;srcid=0116WyUGZhbE9kiPwYGd0x42#rd\">Java LinkedHashMap 源码解析</a>，<a href=\"http://www.cnblogs.com/xrq730/p/5052323.html\">图解集合6：LinkedHashMap</a></p>\n<p>基于 jdk 1.8 分析源码</p>\n<p>LinkedHashMap允许一个null键和多个null值，有序，线程不安全。</p>\n<p>LinkedHashMap直接使用父类HashMap的<strong>数组&amp;链表</strong>结构保存数据，同时自己又采用了<strong>环型双向链表</strong>来维护元素顺序。</p>\n<p>LinkedHashMap提供了两种形式的顺序：<br><strong>访问顺序（access order）</strong>：非常实用，可以使用这种顺序实现LRU（Least Recently Used）缓存（详见get方法解析）<br><strong>插入顺序（insertion orde）</strong>：元素的插入顺序（同一key的多次插入不会影响其顺序，详见newNode方法解析）</p>\n<p>先来看看这两种顺序是的效果：</p>\n<h3 id=\"h3-u8BBFu95EEu987Au5E8F\"><a name=\"访问顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>访问顺序</h3><p><img src=\"http://img.blog.csdn.net/20180116141254497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>可见通过get方法访问了Map中的元素，之后遍历值集合时遍历顺序受到了访问操作的影响，即“最近”被访问的元素排在值集合（即链表）的最前面。</p>\n<p>这样在实现LRU算法时就能很方便的找到最近最少被使用的元素，即链表的头元素。</p>\n<h3 id=\"h3-u63D2u5165u987Au5E8F\"><a name=\"插入顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>插入顺序</h3><p><img src=\"http://img.blog.csdn.net/20180116141752223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>默认采用的就是“插入顺序”。遍历时就会以插入顺序遍历。</p>\n<h2 id=\"h2-entry\"><a name=\"Entry\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Entry</h2><pre><code class=\"lang-java\">    /**\n     * HashMap.Node subclass for normal LinkedHashMap entries.\n     */\n    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {\n        Entry&lt;K,V&gt; before, after;\n        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {\n            super(hash, key, value, next);\n        }\n    }\n</code></pre>\n<p>LinkedHashMap直接使用了HashMap的数据结构来保存元素，不同的是相比HashMap的Entry增加了before和after成员，这两个成员用于维护元素的顺序。</p>\n<h2 id=\"h2-u6784u9020u5668\"><a name=\"构造器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>构造器</h2><pre><code class=\"lang-java\">    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(int initialCapacity,\n                         float loadFactor,\n                         boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n</code></pre>\n<p>LinkedHashMap继承自HashMap，所以构造其中的super调用了父类HashMap的构造器。</p>\n<p>要想使用“访问顺序”形式时只能通过调用三个参数的构造器创建实例。</p>\n', '参考文章：[Java LinkedHashMap 源码解析](https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651479784&idx=1&sn=929e81473146994b15404f4f4d15748e&chksm=bd2532978a52bb81947307b772b39d89566d84a35f6fe55956bb516a357dc92a27e3a498c64c&mpshare=1&scene=23&srcid=0116WyUGZhbE9kiPwYGd0x42#rd)，[图解集合6：LinkedHashMap](http://www.cnblogs.com/xrq730/p/5052323.html)\n\n基于 jdk 1.8 分析源码\n\nLinkedHashMap允许一个null键和多个null值，有序，线程不安全。\n\nLinkedHashMap直接使用父类HashMap的**数组&链表**结构保存数据，同时自己又采用了**环型双向链表**来维护元素顺序。\n\nLinkedHashMap提供了两种形式的顺序：\n**访问顺序（access order）**：非常实用，可以使用这种顺序实现LRU（Least Recently Used）缓存（详见get方法解析）\n**插入顺序（insertion orde）**：元素的插入顺序（同一key的多次插入不会影响其顺序，详见newNode方法解析）\n\n先来看看这两种顺序是的效果：\n### 访问顺序\n![这里写图片描述](http://img.blog.csdn.net/20180116141254497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可见通过get方法访问了Map中的元素，之后遍历值集合时遍历顺序受到了访问操作的影响，即“最近”被访问的元素排在值集合（即链表）的最前面。\n\n这样在实现LRU算法时就能很方便的找到最近最少被使用的元素，即链表的头元素。\n\n### 插入顺序\n![这里写图片描述](http://img.blog.csdn.net/20180116141752223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWltZWltZWlUUw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n默认采用的就是“插入顺序”。遍历时就会以插入顺序遍历。\n\n## Entry\n```java\n    /**\n     * HashMap.Node subclass for normal LinkedHashMap entries.\n     */\n    static class Entry<K,V> extends HashMap.Node<K,V> {\n        Entry<K,V> before, after;\n        Entry(int hash, K key, V value, Node<K,V> next) {\n            super(hash, key, value, next);\n        }\n    }\n```\nLinkedHashMap直接使用了HashMap的数据结构来保存元素，不同的是相比HashMap的Entry增加了before和after成员，这两个成员用于维护元素的顺序。\n\n## 构造器\n```java\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n    \n    public LinkedHashMap(int initialCapacity,\n                         float loadFactor,\n                         boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n```\nLinkedHashMap继承自HashMap，所以构造其中的super调用了父类HashMap的构造器。\n\n要想使用“访问顺序”形式时只能通过调用三个参数的构造器创建实例。\n', 'LinkedHashMap直接使用了HashMap的数据结构来保存元素，不同的是相比HashMap的Entry增加了before和after成员，这两个成员用于维护元素的顺序。', '2018-03-14 17:03:55', '2018-03-14 17:03:55', null, '2816');
INSERT INTO `blog` VALUES ('175', '27', '39', '58', '1', 'java 8 特性小结', '<p>参考文章链接<br><a href=\"http://www.importnew.com/16436.html\">Java8 lambda表达式10个示例</a><br><a href=\"http://www.importnew.com/11908.html\">Java 8新特性终极指南</a></p>\n<h3 id=\"h3-u5C0Fu7ED3\"><a name=\"小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>小结</h3><p>1．    Lambda表达式（闭包）；<br>2．    函数式编程支持： java.util.function.* 下的众多接口；<br>3．    流API；<br>4．    接口的默认方法和静态方法；<br>5．    新的Date和Time API。</p>\n<h3 id=\"h3-1-optional-\"><a name=\"1 Optional 接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 Optional 接口</h3><p><a href=\"http://www.importnew.com/6675.html\">Java 8 Optional类深度解析</a><br>Optional 类对对象的 null 值检测进行包装，如果值存在则 isPresent 返回true，否则 false。</p>\n<h4 id=\"h4-u4E3Bu8981u65B9u6CD5\"><a name=\"主要方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>主要方法</h4><ol>\n<li>Optional.of：创建一个Optional，不能为null，赋值抛出NullPointerException。</li><li>Optional.ofNullable：创建一个可以为 null 的 Optional。</li><li>isPresent：值存在返回true，否则false。</li><li>ifPresent：值存在就调用Consumer对象的accept方法，否则无任何动作。</li><li>get：返回值，空Optional抛NoSuchElementException异常。</li><li>orElse：值存在返回，否则返回指定值。</li><li>orElseGet：值存在返回，否则调用Supplier的get返回。</li><li>orElseThrow：存在返回，否则抛出指定异常。<br>map、flatMap、filter</li></ol>\n<h3 id=\"h3-2-lambda\"><a name=\"2 Lambda\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 Lambda</h3><p>Lambda表达式允许将函数作为一个方法参数传递，或许将代码看成数据。<br>用 () -&gt; {} 代替整个匿名类。</p>\n<p>&lt;java&gt;<br>new Thread( () -&gt; {int i = 9 ; System.out.println(“somting”+i) ; }).start();<br>&lt;/java&gt;<br>() 中参数可省略类型，没有参数时 () 仍然要保留。<br>{} 只有一条语句时 {} 可以省略，语句尾的 ; 也可以省略。<br>&lt;java&gt;<br>Arrays.asList(“a”, “b”, “c”, “d”).forEach(va -&gt; System.out.println(va));<br>&lt;/java&gt;\n\n</p>\n<h3 id=\"h3-3-functionalinterface\"><a name=\"3 FunctionalInterface\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3 FunctionalInterface</h3><p>函数式接口，如果一个接口只有一个方法，那么编译器会将该接口视为函数式接口，如果在接口上加 FunctionalInterface 注解，那么接口就会被强制要求符合函数式接口的规范（只有一个抽象方法，默认，静态方法不包括在内）。</p>\n<h3 id=\"h3-4-predicate-\"><a name=\"4 Predicate 接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4 Predicate 接口</h3><p>适用于过滤元素。<br>该接口有一个test方法，返回boolean，表示检查结果。提供了类似于逻辑操作符AND和OR的方法and()、or()、xor()。可以将多个条件进行组合。</p>\n<p>&lt;java&gt;<br>Predicate&lt;String&gt; testStart = (str) -&gt; str.startsWith(“a”);<br>Predicate&lt;String&gt; testContain = (str) -&gt; str.contains(“b”);<br>boolean result = testStart.and(testContain).test(“acvvb”); // true<br>&lt;/java&gt;<br>### 5 Map 的 Reduce<br>使用示例：map方法（Function接口）遍历并将每一个数乘以2，reduce（BiFunction接口）方法将结果汇总于sum。<br>&lt;java&gt;<br>List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6);<br>Optional&lt;Integer&gt; reduce = list.stream().map(va -&gt; va &gt;&gt; 1).reduce((sum, cur) -&gt; sum += cur);<br>o.accept(reduce.orElse(-1));<br>&lt;/java&gt;<br>### 6 Function&lt;T,R&gt; 接口<br>用于产生对象，函数式接口，接受一个参数，构造并返回目标对象。<br>&lt;java&gt;<br>R apply(T t);<br>&lt;/java&gt;<br>### 7 BiFunction&lt;T,R,U&gt;接口<br>用于产生对象，接受两个参数，生成一个结果。<br>&lt;java&gt;<br>R apply(T t,U u);<br>&lt;/java&gt;<br>### 8 过滤集合元素<br>示例：Filter方法（Predicate接口）遍历元素并检查，返回true保留，collect方法（Collector接口）将结果组合为新的集合。<br>&lt;java&gt;<br>List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6);<br>List&lt;Integer&gt; collect = list.stream().filter(va -&gt; va % 2 == 0).collect(Collectors.toList());<br>o.accept(collect);<br>&lt;/java&gt;<br>### 9 Supplier接口<br>用来产生对象<br>&lt;java&gt;<br>T get();<br>&lt;/java&gt;<br>### 10 计算集合元素的最大，最小，总和以及平均值<br>IntStream、LongStream和DoubleStream中有个summaryStatics方法，可以返回IntSummaryStatics、LongSummaryStatics或DoubleSummaryStatics，描述流中的各种摘要数据。<br>Stream的mapToInt/Long/Double方法可将指定对象作为参数，产生对应的基本类型，mapXXX中接受的接口为：ToInt/Long/DoubleFunction，方法为(以int为例)：int applyToInt(T value);<br>&lt;java&gt;<br>List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6);<br>IntSummaryStatistics statistics = list.stream().mapToInt(i -&gt; i).summaryStatistics();<br>statistics.getMax();<br>statistics.getMin();<br>statistics.getAverage();<br>statistics.getSum();<br>statistics.getCount();<br>&lt;/java&gt;<br>### 11 Lambda VS 匿名内部类<br>this关键字：匿名类的this指向匿名类，而Lambda的this指向外部类。<br>编译方式：Lambda被编译为外部类的私有成员方法，而匿名类被编译为单独的类。<br>同：两种方式在引用外部的局部变量时局部变量要被final修饰。<br>11 方法引用<br>List&lt;Car&gt; cars = new ArrayList&lt;&gt;();<br>1.    方法构造器（无参可访问的构造器）引用：Class::new ，可以便捷的创建一个对象，通常配合Supplier接口使用。<br>2.    引用静态方法（一参可访问）：Class::static_method，通常配合Consumer接口使用。<br>3.    引用特定类的方法（无参可访问）：Class::method<br>4.    引用特定对象的方法：instance::method<br><br>### 12 新的Date/Time API<br>在java.time.<em>包下：<br>新的API涵盖了所有处理日期、时间、时区、过程与时钟的操作。<br>#### (1) Clock类<br>UTC（Universal Time Coordinated）为世界协调时间，与格林尼治时间一样，与英国伦敦时间也一样。北京是东八区，领先于UTC8个小时。<br>&lt;java&gt;<br>Clock clock = Clock.systemUTC();<br>        Instant instant = clock.instant();<br>        Instant plus = instant.plus(8, ChronoUnit.HOURS);// 加 8 小时<br><br>        Instant minus = instant<br>//                .plus(24 </em> 60 <em> 60 </em> 1000, ChronoUnit.MILLIS) // 加一天<br>                .minus(24 <em> 60 </em> 60 * 1000, ChronoUnit.MILLIS);// 减一天<br>        o.accept(instant); // UTC 时间：2017-10-24T07&#58;11&#58;12.576Z<br>        o.accept(plus);// 北京时间：2017-10-24T15&#58;11&#58;12.576Z<br>        o.accept(minus);// UTC 时间减一天：2017-10-23T07&#58;11&#58;12.576Z<br>&lt;/java&gt;<br>#### (2) LocalDate、LocalTime和LocalDateTime<br>三者只持有ISO-8601格式具有时区信息的日期与时间。前两者都可以从Clock中获得。<br>&lt;java&gt;<br>Clock clock = Clock.systemUTC();<br>LocalDate date = LocalDate.now();<br>LocalTime time = LocalTime.now(clock);<br>LocalDateTime dateTime = LocalDateTime.now();<br>o.accept(date); //2017-10-24<br>o.accept(time); // 07&#58;22&#58;07.781 系统时间：15&#58;22&#58;37.050<br>o.accept(time.getNano()); // 319000000<br>o.accept(dateTime); // 2017-10-24T15&#58;23&#58;54.109<br>&lt;/java&gt;<br>#### (3) Duration<br>在秒与纳秒级别上的一段时间。简化了计算两个时间差的不同。<br>&lt;java&gt;<br>Duration duration = Duration.between(<br>        LocalDateTime.of(2014, Month.JULY, 13, 21, 0, 0),        // 2014-07-13 21&#58;00&#58;00<br>        LocalDateTime.of(2014, Month.JULY, 14, 22, 13, 16));      // 2014-07-14 22&#58;13&#58;16<br>o.accept(duration.toDays()); // 1<br>o.accept(duration.toHours()); // 25<br>o.accept(duration.toMinutes()); // 1513<br>o.accept(duration.toNanos()); // 90796000000000<br>&lt;/java&gt;\n\n</p>\n<hr>\n<p>&lt;center&gt;—- END —-&lt;/center&gt;</p>\n', '\n参考文章链接\n[Java8 lambda表达式10个示例](http://www.importnew.com/16436.html )\n[Java 8新特性终极指南](http://www.importnew.com/11908.html )\n\n### 小结\n1．	Lambda表达式（闭包）；\n2．	函数式编程支持： java.util.function.* 下的众多接口；\n3．	流API；\n4．	接口的默认方法和静态方法；\n5．	新的Date和Time API。\n\n###  1 Optional 接口\n[Java 8 Optional类深度解析](http://www.importnew.com/6675.html )\nOptional 类对对象的 null 值检测进行包装，如果值存在则 isPresent 返回true，否则 false。\n\n#### 主要方法\n\n1. Optional.of：创建一个Optional，不能为null，赋值抛出NullPointerException。\n2. Optional.ofNullable：创建一个可以为 null 的 Optional。\n3. isPresent：值存在返回true，否则false。\n4. ifPresent：值存在就调用Consumer对象的accept方法，否则无任何动作。\n5. get：返回值，空Optional抛NoSuchElementException异常。\n6. orElse：值存在返回，否则返回指定值。\n7. orElseGet：值存在返回，否则调用Supplier的get返回。\n8. orElseThrow：存在返回，否则抛出指定异常。\nmap、flatMap、filter\n\n### 2 Lambda\nLambda表达式允许将函数作为一个方法参数传递，或许将代码看成数据。\n用 () -> {} 代替整个匿名类。\n<java>\nnew Thread( () -> {int i = 9 ; System.out.println(“somting”+i) ; }).start();\n</java>\n() 中参数可省略类型，没有参数时 () 仍然要保留。\n{} 只有一条语句时 {} 可以省略，语句尾的 ; 也可以省略。\n<java>\nArrays.asList(“a”, “b”, “c”, “d”).forEach(va -> System.out.println(va));\n</java>\n\n### 3 FunctionalInterface\n函数式接口，如果一个接口只有一个方法，那么编译器会将该接口视为函数式接口，如果在接口上加 FunctionalInterface 注解，那么接口就会被强制要求符合函数式接口的规范（只有一个抽象方法，默认，静态方法不包括在内）。\n### 4 Predicate 接口\n适用于过滤元素。\n该接口有一个test方法，返回boolean，表示检查结果。提供了类似于逻辑操作符AND和OR的方法and()、or()、xor()。可以将多个条件进行组合。\n<java>\nPredicate<String> testStart = (str) -> str.startsWith(\"a\");\nPredicate<String> testContain = (str) -> str.contains(\"b\");\nboolean result = testStart.and(testContain).test(\"acvvb\"); // true\n</java>\n### 5 Map 的 Reduce\n使用示例：map方法（Function接口）遍历并将每一个数乘以2，reduce（BiFunction接口）方法将结果汇总于sum。\n<java>\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);\nOptional<Integer> reduce = list.stream().map(va -> va >> 1).reduce((sum, cur) -> sum += cur);\no.accept(reduce.orElse(-1));\n</java>\n### 6 Function<T,R> 接口\n用于产生对象，函数式接口，接受一个参数，构造并返回目标对象。\n<java>\nR apply(T t);\n</java>\n### 7 BiFunction<T,R,U>接口\n用于产生对象，接受两个参数，生成一个结果。\n<java>\nR apply(T t,U u);\n</java>\n### 8 过滤集合元素\n示例：Filter方法（Predicate接口）遍历元素并检查，返回true保留，collect方法（Collector接口）将结果组合为新的集合。\n<java>\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);\nList<Integer> collect = list.stream().filter(va -> va % 2 == 0).collect(Collectors.toList());\no.accept(collect);\n</java>\n### 9 Supplier接口\n用来产生对象\n<java>\nT get();\n</java>\n### 10 计算集合元素的最大，最小，总和以及平均值\nIntStream、LongStream和DoubleStream中有个summaryStatics方法，可以返回IntSummaryStatics、LongSummaryStatics或DoubleSummaryStatics，描述流中的各种摘要数据。\nStream的mapToInt/Long/Double方法可将指定对象作为参数，产生对应的基本类型，mapXXX中接受的接口为：ToInt/Long/DoubleFunction，方法为(以int为例)：int applyToInt(T value);\n<java>\nList<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);\nIntSummaryStatistics statistics = list.stream().mapToInt(i -> i).summaryStatistics();\nstatistics.getMax();\nstatistics.getMin();\nstatistics.getAverage();\nstatistics.getSum();\nstatistics.getCount();\n</java>\n### 11 Lambda VS 匿名内部类\nthis关键字：匿名类的this指向匿名类，而Lambda的this指向外部类。\n编译方式：Lambda被编译为外部类的私有成员方法，而匿名类被编译为单独的类。\n同：两种方式在引用外部的局部变量时局部变量要被final修饰。\n11 方法引用\nList<Car> cars = new ArrayList<>();\n1.	方法构造器（无参可访问的构造器）引用：Class::new ，可以便捷的创建一个对象，通常配合Supplier接口使用。\n2.	引用静态方法（一参可访问）：Class::static_method，通常配合Consumer接口使用。\n3.	引用特定类的方法（无参可访问）：Class::method\n4.	引用特定对象的方法：instance::method\n\n### 12 新的Date/Time API\n在java.time.*包下：\n新的API涵盖了所有处理日期、时间、时区、过程与时钟的操作。\n#### (1) Clock类\nUTC（Universal Time Coordinated）为世界协调时间，与格林尼治时间一样，与英国伦敦时间也一样。北京是东八区，领先于UTC8个小时。\n<java>\nClock clock = Clock.systemUTC();\n        Instant instant = clock.instant();\n        Instant plus = instant.plus(8, ChronoUnit.HOURS);// 加 8 小时\n\n        Instant minus = instant\n//                .plus(24 * 60 * 60 * 1000, ChronoUnit.MILLIS) // 加一天\n                .minus(24 * 60 * 60 * 1000, ChronoUnit.MILLIS);// 减一天\n        o.accept(instant); // UTC 时间：2017-10-24T07:11:12.576Z\n        o.accept(plus);// 北京时间：2017-10-24T15:11:12.576Z\n        o.accept(minus);// UTC 时间减一天：2017-10-23T07:11:12.576Z\n</java>\n#### (2) LocalDate、LocalTime和LocalDateTime\n三者只持有ISO-8601格式具有时区信息的日期与时间。前两者都可以从Clock中获得。\n<java>\nClock clock = Clock.systemUTC();\nLocalDate date = LocalDate.now();\nLocalTime time = LocalTime.now(clock);\nLocalDateTime dateTime = LocalDateTime.now();\no.accept(date); //2017-10-24\no.accept(time); // 07:22:07.781 系统时间：15:22:37.050\no.accept(time.getNano()); // 319000000\no.accept(dateTime); // 2017-10-24T15:23:54.109\n</java>\n#### (3) Duration\n在秒与纳秒级别上的一段时间。简化了计算两个时间差的不同。\n<java>\nDuration duration = Duration.between(\n        LocalDateTime.of(2014, Month.JULY, 13, 21, 0, 0),        // 2014-07-13 21:00:00\n        LocalDateTime.of(2014, Month.JULY, 14, 22, 13, 16));      // 2014-07-14 22:13:16\no.accept(duration.toDays()); // 1\no.accept(duration.toHours()); // 25\no.accept(duration.toMinutes()); // 1513\no.accept(duration.toNanos()); // 90796000000000\n</java>\n\n---\n<center>--- END ---</center>', '函数式接口，如果一个接口只有一个方法，那么编译器会将该接口视为函数式接口，如果在接口上加 FunctionalInterface 注解，那么接口就会被强制要求符合函数式接口的规范（只有一个抽象方法，默认，静态方法不包括在内）。', '2018-03-23 09:33:12', '2018-03-23 09:33:12', null, '6358');
INSERT INTO `blog` VALUES ('178', '29', '47 48 49', '66 64', '1', 'java volatile 关键字', '<blockquote>\n<p>关键字volatile是java虚拟机提供的<strong>最轻量级的同步机制</strong>。java内存模型对volatile专门定义了一些特殊的访问规则。</p>\n</blockquote>\n<h2 id=\"h2-u7279u6027\"><a name=\"特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>特性</h2><p>当一个变量被volatile修饰后，它具备两种特性，第一是保证此变量对所有线程的可见性；第二是禁止指令重拍序。</p>\n<h3 id=\"h3--\"><a name=\"保证可见性，不保证操作原子性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>保证可见性，不保证操作原子性</h3><p>这里的“可见性”值当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量做不到这一点，普通变量的值在线程中传递均需要通过主存来完成。</p>\n<p>在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都需要先刷新，执行引擎看不到不一致的情况（不一致是存在的，允许的），因此可以认为不存在一致性问题。<strong>但是java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全（volatile不保证操作原子性）</strong>。</p>\n<p>例如定义如下变量：<br><code>private static volatile int va = 0;</code><br>然后开启10个线程，在每个线程中对va累加1000次，那么最终期望的va的值为10000。但由于同步的问题，最终的结果会出现不等于10000的情况（往往小于10000）。<br><code>va++</code>操作对应的字节码指令如下：</p>\n<pre><code>1 getstatic\n2 iconst_1\n3 iadd\n4 putstatic\n</code></pre><p>可见一个自增操作需要四个字节码指令完成，getstatic用于获得静态变量的值（这里保证了可见性，每次使用都刷新值），2、3两条指令执行值加一操作，putstatic将新增回写（保证可见性）。</p>\n<p>volatile不保证操作原子性意味着这4条指令有可能会被中断，如当前va=3，线程A执行到指令2，此时线程A因为某种原因放弃执行权（如Thread.yield()），线程B经调度获得执行权，并且完整的执行4条指令并放弃执行权，此时va=4，线程A重新获得执行权并从上次停下来的地方继续执行，执行2、3指令，此时线程A的工作内存中va的值为4，执行putstatic指令，最终va的值为4。<br>这里va被两个线程累加了两次，最终值理应为5，但由于不保证操作原子性的关系，最终值为4，小于期望值。</p>\n<h3 id=\"h3-u7981u6B62u6307u4EE4u91CDu62CDu5E8F\"><a name=\"禁止指令重拍序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>禁止指令重拍序</h3><p>普通的变量仅仅会保证在所有依赖当前值进行赋值的地方都能获取到正确的值，而不保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>\n<p>有如下代码：</p>\n<pre><code class=\"lang-java\">Map configOptions;\nchar[] configText;\n// 此变量必须为volatile\nvolatile boolean initialized = false;\n\n// 假设以下代码在线程A中执行\n// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(fileName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n// 假设以下代码在线程B中执行\n// 等待initialized为true，代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n    sleep();\n}\ndoSomethingWithConfig();\n</code></pre>\n<p>如果定义的initialized变量没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中的最后一句代码<code>initialized = true;</code>被提前执行，那么线程B在执行<code>doSomethingWithConfig()</code>可能就会出错。</p>\n<p>volatile屏蔽指令重拍序的语义在 jdk 1.5 中才被完全修复，此前的JDK中即使变量被声明为volatile也仍然不能完全避免重排序导致的问题。</p>\n<h2 id=\"h2-u5E95u5C42u5B9Eu73B0\"><a name=\"底层实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>底层实现</h2><p>被volatile修饰的变量，执行赋值操作后会生成一个内存屏障（Memory Barrier或Memory Fence，指重拍序时不能把后面的指令重拍序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或多个CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p>\n<h2 id=\"h2-volatile-\"><a name=\"volatile与锁\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>volatile与锁</h2><p>在某些情况下，volatile机制的性能确实要优于锁（synchronized或java.util.concurrent包里面的锁），但由于虚拟机对锁实现的许多消除和优化，使得我们很难量化的认为volatile就会比锁快多少。</p>\n<p>使用volatile可以确定的一个原则是：<strong>volatile变量的读操作的性能消耗与普通变量几乎没差别，但是写操作可能会慢一些。</strong>因为它需要在本地代码中插入许多内存屏障指令来保证不发生乱序执行。不过即便如此，<strong>大多数场景下volatile的总开销仍然要比锁低。</strong></p>\n<hr>\n<p>博文内容摘抄自《深入理解java虚拟机》第12章 Java内存模型与线程 12.3.3: 对于volatile型变量的特殊规则</p>\n<p>&lt;center&gt;—-END—-&lt;/center&gt;</p>\n', '> \n关键字volatile是java虚拟机提供的**最轻量级的同步机制**。java内存模型对volatile专门定义了一些特殊的访问规则。\n\n## 特性\n当一个变量被volatile修饰后，它具备两种特性，第一是保证此变量对所有线程的可见性；第二是禁止指令重拍序。\n\n### 保证可见性，不保证操作原子性\n这里的“可见性”值当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量做不到这一点，普通变量的值在线程中传递均需要通过主存来完成。\n\n在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都需要先刷新，执行引擎看不到不一致的情况（不一致是存在的，允许的），因此可以认为不存在一致性问题。**但是java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全（volatile不保证操作原子性）**。\n\n例如定义如下变量：\n`private static volatile int va = 0;`\n然后开启10个线程，在每个线程中对va累加1000次，那么最终期望的va的值为10000。但由于同步的问题，最终的结果会出现不等于10000的情况（往往小于10000）。\n`va++`操作对应的字节码指令如下：\n```\n1 getstatic\n2 iconst_1\n3 iadd\n4 putstatic\n```\n可见一个自增操作需要四个字节码指令完成，getstatic用于获得静态变量的值（这里保证了可见性，每次使用都刷新值），2、3两条指令执行值加一操作，putstatic将新增回写（保证可见性）。\n\nvolatile不保证操作原子性意味着这4条指令有可能会被中断，如当前va=3，线程A执行到指令2，此时线程A因为某种原因放弃执行权（如Thread.yield()），线程B经调度获得执行权，并且完整的执行4条指令并放弃执行权，此时va=4，线程A重新获得执行权并从上次停下来的地方继续执行，执行2、3指令，此时线程A的工作内存中va的值为4，执行putstatic指令，最终va的值为4。\n这里va被两个线程累加了两次，最终值理应为5，但由于不保证操作原子性的关系，最终值为4，小于期望值。\n\n### 禁止指令重拍序\n普通的变量仅仅会保证在所有依赖当前值进行赋值的地方都能获取到正确的值，而不保证变量赋值操作的顺序与程序代码中的执行顺序一致。\n\n有如下代码：\n```java\nMap configOptions;\nchar[] configText;\n// 此变量必须为volatile\nvolatile boolean initialized = false;\n\n// 假设以下代码在线程A中执行\n// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用\nconfigOptions = new HashMap();\nconfigText = readConfigFile(fileName);\nprocessConfigOptions(configText,configOptions);\ninitialized = true;\n\n// 假设以下代码在线程B中执行\n// 等待initialized为true，代表线程A已经把配置信息初始化完成\nwhile(!initialized){\n    sleep();\n}\ndoSomethingWithConfig();\n\n```\n如果定义的initialized变量没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中的最后一句代码`initialized = true;`被提前执行，那么线程B在执行`doSomethingWithConfig()`可能就会出错。\n\nvolatile屏蔽指令重拍序的语义在 jdk 1.5 中才被完全修复，此前的JDK中即使变量被声明为volatile也仍然不能完全避免重排序导致的问题。\n\n## 底层实现\n被volatile修饰的变量，执行赋值操作后会生成一个内存屏障（Memory Barrier或Memory Fence，指重拍序时不能把后面的指令重拍序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或多个CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。\n\n## volatile与锁\n在某些情况下，volatile机制的性能确实要优于锁（synchronized或java.util.concurrent包里面的锁），但由于虚拟机对锁实现的许多消除和优化，使得我们很难量化的认为volatile就会比锁快多少。\n\n使用volatile可以确定的一个原则是：**volatile变量的读操作的性能消耗与普通变量几乎没差别，但是写操作可能会慢一些。**因为它需要在本地代码中插入许多内存屏障指令来保证不发生乱序执行。不过即便如此，**大多数场景下volatile的总开销仍然要比锁低。**\n\n----\n博文内容摘抄自《深入理解java虚拟机》第12章 Java内存模型与线程 12.3.3: 对于volatile型变量的特殊规则\n\n<center>---END---</center>', '当一个变量被volatile修饰后，它具备两种特性，第一是保证此变量对所有线程的可见性；第二是禁止指令重拍序。', '2018-03-23 10:18:36', '2018-03-23 10:19:30', null, '3128');
INSERT INTO `blog` VALUES ('179', '1', '25', '39 53 3 47 37', '1', '扶门的礼仪', '<p>世界上的很多事情，不是你自己有好意就一定有好的效果，你还必须知道对方的感受，不然你也许会让对方感觉很累。今天我就来讲讲一个看似简单的礼仪：扶门。很多中国人到了国外，特别是美国，看到美国人进了公共场所的大门之后，为了防止门回弹关上，都会礼貌地为后面的人扶住门，等他们接住门才放手。甚至有些先把门拉开，站在门口扶住门，让后面的人都进去了，自己才进去。</p>\n<p>中国人看到美国人这么做，觉得扶门是文明的象征，所以也开始模仿。哪知道，这里面的学问其实比他们想象的要复杂一些。所以你就发现，某些人经常为“谁先进门”这个事情让来让去的，又尴尬又累，那程度胜似吃了饭抢着买单 :p 其中的一些道理，其实很多美国人都不懂。这些道理可能很难在其它地方看到，所以我把它们总结一下。</p>\n<p>显然这些主动为后面人扶门的人，比起那些完全不考虑别人，甚至使劲摔门的人来说，已经很好了。可是我今天要说的不是这个，而是更加深入细致的礼仪。美国作为一个基本文明的国家，在这方面做得已经不错了，可是相对某些欧洲国家还是稍显落后。很多美国人并不懂得完整合理的礼仪规范，只是模仿欧洲的“绅士风度”，所以有些时候做得其实不大对。所以呢，看到美国人那么做，你也不一定完全模仿他们。你应该知道这些礼仪背后的原理，而不是照抄表面现象。</p>\n<p>分情况讨论<br>扶门也许不是你想象的那么简单，无条件扶着门，显示好意就好。很多人懂得应该为后面的人扶门，可是他们忽视了扶门的时机问题，还有人之间的关系问题。正确的作法应该是这样，分好几种情况。</p>\n<p>情况 1：陌生人。进了一扇会自动弹回关上的门，如果回头看到有陌生人紧跟在后面，只有两三步远的地方，就扶住门让他进来，否则就自然把门放开，自己进去就是。原因是，如果后面的人离你还很远，扶住门会迫使他加快脚步。后面的人很可能希望按照自己的节奏走路，可是看到你扶住门等他，不好意思让你久等，或者觉得你一直回头看着他挺尴尬，所以他不得不加快脚步。如果他刚吃了饭不想那么快步走，或者他是在上楼梯，就会更加不舒服。所以呢，出于对他人真正周全的考虑，你不应该扶住门时间太久，迫使后面的人加快脚步。如果你发现自己判断错误，扶住门太久了，你还是可以补救。你只需要微笑着朝后面的人挥挥手，然后放开门自己进去。他会理解你为什么放手，因为他也不会指望你扶太久。这一条原则经常被美国人忽视，遇到扶门太久太早的人，经常感觉挺累。如果你遇到为你扶门太久的人，你也可以朝他挥挥手，示意他先走。</p>\n<p>情况 2：认识的人或者朋友。当然对于认识的人或者朋友同事，第一条就不一定需要严格遵守了。因为后面那个人认识你而且关系不错，所以你可以扶住门比较长时间。他大概不会因为你在那等他而加快脚步，你甚至可以靠着门跟他说句话。当然如果实在太远了，你也同样可以挥挥手，放手进去，别人不会介意这个。</p>\n<p>情况 3：陌生女性。如果身后紧跟的是陌生女性，你可以拉开门，让她先进去，然后自己才进去。你也可以自己先进去，然后把门帮她扶一下。没有规则要你一定让女性先进去，或者扶住门太久。普通的女性完全有能力拉开一扇门，这个不需要你特别照顾。</p>\n<p>情况 4：男性。如果身后紧跟的是男性，不管你是否认识他，你最好自己先进去，然后帮他扶一下门。最好不要请他先走，否则你就会制造“让来让去”的尴尬局面！如果你拉开门让一个男性先进去，自己才进去，会造成这位男性的尴尬。凭什么我需要让另一个男性，甚至是女性为我开门，让我先走呢？这就像在公车上有人给我让座，我有老弱病残孕到那种地步吗？他会这样想。他会认为自己的男性气质受到了某种打击，或者感到尴尬，感到欠了你什么。当然，如果你是酒店的礼宾人员，为客人开门让他们先走，不论男女都是天经地义的。如果你是主人，接待一位客人，给他开门也是天经地义的。其它的情况就不一定了。所以当男性遇到另一个男性或者女性（非礼宾人员，非东道主）给他开门，他一般会示意对方先走，可是扶门的这个人却又坚持要他先走，最后就出现了僵持的尴尬局面。这跟很多中国人吃了饭抢着买单一样讨厌，有人似乎觉得谁先进了门谁就输了，认为给别人开门的人更 man！所以你开了门，干脆不要请身后的男性先走，就不会有这回事了，进去时帮他扶一下门不是一样的效果吗？如果开门的人在多次反复之后一定要你先走，而且多次进门都那样，那么请你今后小心这个人了。他似乎很想要你感觉欠他什么，或者想显得比你更 man……</p>\n<p>情况 5：两手被占用的人。两手抱着箱子，或者推着自行车的人，如果跟在你身后，他们需要特殊照顾。你应该扶住门，让他们先走，然后自己才走。这个规则不论男女老幼，不论跟你什么关系都一样适用，因为他们腾不出手来开门，也没有手可以接住你放开的门。</p>\n<p>情况 6：一个推着婴儿车的人。如果是一个人推着一个婴儿车，这个没什么好说的，一定要拉开门，让他先走，确认婴儿车已经进去了，自己才进去。还有一种情况是一家人，其中一个推着婴儿车。因为有人可以开门，这个就不需要你特别照顾了，按情况1处理。</p>\n<p>情况 7：一大群普通关系的人（或者同事）在你后面。如果你身后不是一个人，而是一大群人，而且这群人不是亲密的朋友，只是普通的同学或者同事关系，那么请你先进去，然后帮后面第一个人扶住门，等他接手门之后就放手。他会为后面的人扶一下，这样接力下去。不要站在门口，让一大群人都进去，然后自己才进去。有些人喜欢这样做，以为这样显得很“绅士”，但我觉得这样很装很做作。我见过两三个喜欢扶住门让所有人进去的人，在工作中都是很虚伪的人。他们在工作中可以暗地里捅你几刀，进门的时候却演得像个大好人。让大家进去他才走，得意洋洋的样子，好像每个人走过那道门都欠了他一笔账似的。真的，你没有必要那样做，那种感觉非常的不自然。而且你扶住门，看着后面每个人走向你，可能会让某些人尴尬。其中某些人可能不大喜欢你，不想跟你近距离对视，觉得你在借机打量他们。有些女性甚至会觉得你长时间盯着她们走进去，是一种骚扰。所以如果很多人一起，最好还是你自己先进去，不要站在门口给大家扶门。</p>\n<p>情况 8：跟女性朋友一起。如果你是男性，跟熟悉的女性朋友或者女朋友一起，你最好拉开门，让女性朋友先进去，然后自己马上跟进去。注意，跟进去的时机是“马上”。如果她身后紧跟着陌生人，请紧跟在你的女性朋友身后进门，不要让陌生人夹到你们中间去。有些刚懂得扶门的男士不知道这个道理。他拉开门，让女性朋友进去了，结果看到她身后又跟着其他陌生人，所以他继续扶着门，让其他人先走。结果门外的人一个个都进去了，他还在那里扶着门。女性朋友在里面，都不知道他哪里去了 :p 这种男士应该明白的是，在这个时候你应该跟女性朋友待在一起，而不应该让陌生人隔在你们之间。没有人会因为你先走而责怪你，他们反而会觉得你让他们先走很奇怪，因为你应该首先照顾自己的朋友。Credit: 以上对待女性朋友的开门原则，我是从 Emily Post 经典的『Etiquette』（礼仪）一书看到的。当然，如果碰巧你们身后有人推着婴儿车，你可以让女性朋友进去，然后让婴儿车进去，然后你马上跟进去，不要再让其他人。</p>\n<p>情况 9：进门马上需要排队的地方。如果你是去邮局或者需要排队下单的咖啡店，除非后面的人真有困难，最好不要拉开门让后面的陌生人先走，即使后面是女性也一样。你应该自己先进去，然后稍微扶一下门。根据先来先服务的原则，你应该排在后面的人前面，不管后面是男是女。如果你拉门让别人先走了，他们自然就排到你前面去了。如果这个人特别懂礼仪而且考虑周到，她可能会让你到前面去排队。但如果你在一个不是每个人都那么懂的地方，她很可能意识不到你应该排在她前面。这样你显示了好意反而吃亏，这会打击你以后继续有礼貌的动机。</p>\n', '世界上的很多事情，不是你自己有好意就一定有好的效果，你还必须知道对方的感受，不然你也许会让对方感觉很累。今天我就来讲讲一个看似简单的礼仪：扶门。很多中国人到了国外，特别是美国，看到美国人进了公共场所的大门之后，为了防止门回弹关上，都会礼貌地为后面的人扶住门，等他们接住门才放手。甚至有些先把门拉开，站在门口扶住门，让后面的人都进去了，自己才进去。\n\n中国人看到美国人这么做，觉得扶门是文明的象征，所以也开始模仿。哪知道，这里面的学问其实比他们想象的要复杂一些。所以你就发现，某些人经常为“谁先进门”这个事情让来让去的，又尴尬又累，那程度胜似吃了饭抢着买单 :p 其中的一些道理，其实很多美国人都不懂。这些道理可能很难在其它地方看到，所以我把它们总结一下。\n\n显然这些主动为后面人扶门的人，比起那些完全不考虑别人，甚至使劲摔门的人来说，已经很好了。可是我今天要说的不是这个，而是更加深入细致的礼仪。美国作为一个基本文明的国家，在这方面做得已经不错了，可是相对某些欧洲国家还是稍显落后。很多美国人并不懂得完整合理的礼仪规范，只是模仿欧洲的“绅士风度”，所以有些时候做得其实不大对。所以呢，看到美国人那么做，你也不一定完全模仿他们。你应该知道这些礼仪背后的原理，而不是照抄表面现象。\n\n分情况讨论\n扶门也许不是你想象的那么简单，无条件扶着门，显示好意就好。很多人懂得应该为后面的人扶门，可是他们忽视了扶门的时机问题，还有人之间的关系问题。正确的作法应该是这样，分好几种情况。\n\n情况 1：陌生人。进了一扇会自动弹回关上的门，如果回头看到有陌生人紧跟在后面，只有两三步远的地方，就扶住门让他进来，否则就自然把门放开，自己进去就是。原因是，如果后面的人离你还很远，扶住门会迫使他加快脚步。后面的人很可能希望按照自己的节奏走路，可是看到你扶住门等他，不好意思让你久等，或者觉得你一直回头看着他挺尴尬，所以他不得不加快脚步。如果他刚吃了饭不想那么快步走，或者他是在上楼梯，就会更加不舒服。所以呢，出于对他人真正周全的考虑，你不应该扶住门时间太久，迫使后面的人加快脚步。如果你发现自己判断错误，扶住门太久了，你还是可以补救。你只需要微笑着朝后面的人挥挥手，然后放开门自己进去。他会理解你为什么放手，因为他也不会指望你扶太久。这一条原则经常被美国人忽视，遇到扶门太久太早的人，经常感觉挺累。如果你遇到为你扶门太久的人，你也可以朝他挥挥手，示意他先走。\n\n情况 2：认识的人或者朋友。当然对于认识的人或者朋友同事，第一条就不一定需要严格遵守了。因为后面那个人认识你而且关系不错，所以你可以扶住门比较长时间。他大概不会因为你在那等他而加快脚步，你甚至可以靠着门跟他说句话。当然如果实在太远了，你也同样可以挥挥手，放手进去，别人不会介意这个。\n\n情况 3：陌生女性。如果身后紧跟的是陌生女性，你可以拉开门，让她先进去，然后自己才进去。你也可以自己先进去，然后把门帮她扶一下。没有规则要你一定让女性先进去，或者扶住门太久。普通的女性完全有能力拉开一扇门，这个不需要你特别照顾。\n\n情况 4：男性。如果身后紧跟的是男性，不管你是否认识他，你最好自己先进去，然后帮他扶一下门。最好不要请他先走，否则你就会制造“让来让去”的尴尬局面！如果你拉开门让一个男性先进去，自己才进去，会造成这位男性的尴尬。凭什么我需要让另一个男性，甚至是女性为我开门，让我先走呢？这就像在公车上有人给我让座，我有老弱病残孕到那种地步吗？他会这样想。他会认为自己的男性气质受到了某种打击，或者感到尴尬，感到欠了你什么。当然，如果你是酒店的礼宾人员，为客人开门让他们先走，不论男女都是天经地义的。如果你是主人，接待一位客人，给他开门也是天经地义的。其它的情况就不一定了。所以当男性遇到另一个男性或者女性（非礼宾人员，非东道主）给他开门，他一般会示意对方先走，可是扶门的这个人却又坚持要他先走，最后就出现了僵持的尴尬局面。这跟很多中国人吃了饭抢着买单一样讨厌，有人似乎觉得谁先进了门谁就输了，认为给别人开门的人更 man！所以你开了门，干脆不要请身后的男性先走，就不会有这回事了，进去时帮他扶一下门不是一样的效果吗？如果开门的人在多次反复之后一定要你先走，而且多次进门都那样，那么请你今后小心这个人了。他似乎很想要你感觉欠他什么，或者想显得比你更 man……\n\n情况 5：两手被占用的人。两手抱着箱子，或者推着自行车的人，如果跟在你身后，他们需要特殊照顾。你应该扶住门，让他们先走，然后自己才走。这个规则不论男女老幼，不论跟你什么关系都一样适用，因为他们腾不出手来开门，也没有手可以接住你放开的门。\n\n情况 6：一个推着婴儿车的人。如果是一个人推着一个婴儿车，这个没什么好说的，一定要拉开门，让他先走，确认婴儿车已经进去了，自己才进去。还有一种情况是一家人，其中一个推着婴儿车。因为有人可以开门，这个就不需要你特别照顾了，按情况1处理。\n\n情况 7：一大群普通关系的人（或者同事）在你后面。如果你身后不是一个人，而是一大群人，而且这群人不是亲密的朋友，只是普通的同学或者同事关系，那么请你先进去，然后帮后面第一个人扶住门，等他接手门之后就放手。他会为后面的人扶一下，这样接力下去。不要站在门口，让一大群人都进去，然后自己才进去。有些人喜欢这样做，以为这样显得很“绅士”，但我觉得这样很装很做作。我见过两三个喜欢扶住门让所有人进去的人，在工作中都是很虚伪的人。他们在工作中可以暗地里捅你几刀，进门的时候却演得像个大好人。让大家进去他才走，得意洋洋的样子，好像每个人走过那道门都欠了他一笔账似的。真的，你没有必要那样做，那种感觉非常的不自然。而且你扶住门，看着后面每个人走向你，可能会让某些人尴尬。其中某些人可能不大喜欢你，不想跟你近距离对视，觉得你在借机打量他们。有些女性甚至会觉得你长时间盯着她们走进去，是一种骚扰。所以如果很多人一起，最好还是你自己先进去，不要站在门口给大家扶门。\n\n情况 8：跟女性朋友一起。如果你是男性，跟熟悉的女性朋友或者女朋友一起，你最好拉开门，让女性朋友先进去，然后自己马上跟进去。注意，跟进去的时机是“马上”。如果她身后紧跟着陌生人，请紧跟在你的女性朋友身后进门，不要让陌生人夹到你们中间去。有些刚懂得扶门的男士不知道这个道理。他拉开门，让女性朋友进去了，结果看到她身后又跟着其他陌生人，所以他继续扶着门，让其他人先走。结果门外的人一个个都进去了，他还在那里扶着门。女性朋友在里面，都不知道他哪里去了 :p 这种男士应该明白的是，在这个时候你应该跟女性朋友待在一起，而不应该让陌生人隔在你们之间。没有人会因为你先走而责怪你，他们反而会觉得你让他们先走很奇怪，因为你应该首先照顾自己的朋友。Credit: 以上对待女性朋友的开门原则，我是从 Emily Post 经典的『Etiquette』（礼仪）一书看到的。当然，如果碰巧你们身后有人推着婴儿车，你可以让女性朋友进去，然后让婴儿车进去，然后你马上跟进去，不要再让其他人。\n\n情况 9：进门马上需要排队的地方。如果你是去邮局或者需要排队下单的咖啡店，除非后面的人真有困难，最好不要拉开门让后面的陌生人先走，即使后面是女性也一样。你应该自己先进去，然后稍微扶一下门。根据先来先服务的原则，你应该排在后面的人前面，不管后面是男是女。如果你拉门让别人先走了，他们自然就排到你前面去了。如果这个人特别懂礼仪而且考虑周到，她可能会让你到前面去排队。但如果你在一个不是每个人都那么懂的地方，她很可能意识不到你应该排在她前面。这样你显示了好意反而吃亏，这会打击你以后继续有礼貌的动机。', '中国人看到美国人这么做，觉得扶门是文明的象征，所以也开始模仿。哪知道，这里面的学问其实比他们想象的要复杂一些。所以你就发现，某些人经常为“谁先进门”这个事情让来让去的，又尴尬又累，那程度胜似吃了饭抢着买单 :p 其中的一些道理，其实很多美国人都不懂。这些道理可能很难在其它地方看到，所以我把它们总结一下。', '2018-04-03 11:26:06', '2018-04-03 11:26:06', null, '3227');

-- ----------------------------
-- Table structure for `blogger_account`
-- ----------------------------
DROP TABLE IF EXISTS `blogger_account`;
CREATE TABLE `blogger_account` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '博主id',
  `username` varchar(50) NOT NULL COMMENT '博主用户名',
  `password` varchar(100) NOT NULL COMMENT '博主密码',
  `register_date` datetime NOT NULL COMMENT '注册时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blogger_account
-- ----------------------------
INSERT INTO `blogger_account` VALUES ('1', 'duan', '557335108979346270264201884256145555018465277730', '2017-12-12 18:05:32');
INSERT INTO `blogger_account` VALUES ('22', 'spring-13', '-501838232220656037777046917875770484484956052853', '2018-03-07 15:52:13');
INSERT INTO `blogger_account` VALUES ('24', 'jack12', '19292575359224636984851458476205732208095430756', '2018-03-14 16:45:19');
INSERT INTO `blogger_account` VALUES ('25', 'rose13', '621258123970632511850866247971096502120474756342', '2018-03-14 17:02:36');
INSERT INTO `blogger_account` VALUES ('27', 'Tony', '23871569922208005474531710247733891940212489930', '2018-03-23 09:29:45');
INSERT INTO `blogger_account` VALUES ('29', 'tony14', '-540609720282100124011154299525235498985769168', '2018-03-23 10:04:16');

-- ----------------------------
-- Table structure for `blogger_link`
-- ----------------------------
DROP TABLE IF EXISTS `blogger_link`;
CREATE TABLE `blogger_link` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '博主友情链接id',
  `blogger_id` int(10) unsigned NOT NULL COMMENT '链接所属博主id',
  `icon_id` int(10) unsigned DEFAULT NULL COMMENT '图标id',
  `title` varchar(50) NOT NULL COMMENT '链接标题',
  `url` varchar(200) NOT NULL COMMENT '链接url',
  `bewrite` varchar(100) DEFAULT NULL COMMENT '链接描述',
  PRIMARY KEY (`id`),
  UNIQUE KEY `blogger_id` (`blogger_id`,`url`),
  KEY `icon_id` (`icon_id`),
  CONSTRAINT `blogger_link_ibfk_1` FOREIGN KEY (`blogger_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `blogger_link_ibfk_2` FOREIGN KEY (`icon_id`) REFERENCES `blogger_picture` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=66 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blogger_link
-- ----------------------------
INSERT INTO `blogger_link` VALUES ('1', '1', null, 'GitHub-13', 'https://github.com/DuanJiaNing', 'DuanJiaNing');
INSERT INTO `blogger_link` VALUES ('5', '1', null, 'GitHub', 'http://www.github.com', '有说明');
INSERT INTO `blogger_link` VALUES ('51', '1', null, '简叔', 'http://jianshu.com', '简叔');
INSERT INTO `blogger_link` VALUES ('52', '22', null, 'csdn', 'http://csdn.com', 'csdn');
INSERT INTO `blogger_link` VALUES ('53', '22', null, 'github', 'https://github.com', 'showChoosedLinkDetail');
INSERT INTO `blogger_link` VALUES ('57', '1', null, 'vfd', 'http://ccfff.com', '');
INSERT INTO `blogger_link` VALUES ('60', '27', null, 'csdn', 'http://blog.csdn.com', '');
INSERT INTO `blogger_link` VALUES ('61', '27', null, 'GitHub', 'https://github.com/DuanJiaNing', 'duan 的 Github');
INSERT INTO `blogger_link` VALUES ('65', '29', null, 'csdn', 'http://blog.csdn.net', '我的 csdn 博客');

-- ----------------------------
-- Table structure for `blogger_picture`
-- ----------------------------
DROP TABLE IF EXISTS `blogger_picture`;
CREATE TABLE `blogger_picture` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '照片id',
  `blogger_id` int(11) unsigned NOT NULL COMMENT '照片所属博主id',
  `bewrite` text COMMENT '照片描述',
  `category` int(11) NOT NULL DEFAULT '0' COMMENT '照片类别',
  `path` varchar(230) NOT NULL COMMENT '照片保存位置',
  `title` varchar(200) NOT NULL COMMENT '照片标题',
  `upload_date` datetime NOT NULL COMMENT '照片上传日期',
  `use_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '图片被引用次数',
  PRIMARY KEY (`id`),
  KEY `blogger_id` (`blogger_id`),
  CONSTRAINT `blogger_picture_ibfk_1` FOREIGN KEY (`blogger_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=181 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blogger_picture
-- ----------------------------
INSERT INTO `blogger_picture` VALUES ('86', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1516346462271-２.png', '２', '2018-01-19 15:21:02', '0');
INSERT INTO `blogger_picture` VALUES ('87', '1', '', '11', 'E:\\blog\\blogger\\image\\duan\\DEFAULT_BLOGGER_LINK_ICON\\1516346527635-favicon.png', 'favicon', '2018-01-19 15:22:07', '0');
INSERT INTO `blogger_picture` VALUES ('88', '1', '', '12', 'E:\\blog\\blogger\\image\\duan\\DEFAULT_BLOGGER_BLOG_CATEGORY_ICON\\1516346533446-格式工厂34cb86e4d8af93bea28328a29fb0cf990062675d172f2-8OnLgc.png', '格式工厂34cb86e4d8af93bea28328a29fb0cf990062675d172f2-8OnLgc', '2018-01-19 15:22:13', '0');
INSERT INTO `blogger_picture` VALUES ('89', '1', '', '14', 'E:\\blog\\blogger\\image\\duan\\DEFAULT_BLOGGER_BLOG_PICTURE\\1516346539722-格式工厂0782c798deb85deb14f8c4ae7978ac19183a15fa19385-e9JH52.png', '格式工厂0782c798deb85deb14f8c4ae7978ac19183a15fa19385-e9JH52', '2018-01-19 15:22:19', '0');
INSERT INTO `blogger_picture` VALUES ('90', '1', '', '15', 'E:\\blog\\blogger\\image\\duan\\DEFAULT_PICTURE\\1516346546125-格式工厂165923deo0hgcz0g1kkoq6.png', '格式工厂165923deo0hgcz0g1kkoq6', '2018-01-19 15:22:26', '0');
INSERT INTO `blogger_picture` VALUES ('91', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1516346552949-格式工厂522014_大叔有点萌-2 (2).png', '格式工厂522014_大叔有点萌-2 (2)', '2018-01-19 15:22:32', '0');
INSERT INTO `blogger_picture` VALUES ('95', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1516348614441-１１１.png', '１１１', '2018-01-19 15:56:54', '0');
INSERT INTO `blogger_picture` VALUES ('96', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1516348619663-１１４.png', '１１４', '2018-01-19 15:56:59', '0');
INSERT INTO `blogger_picture` VALUES ('97', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1516348625453-１１８.png', '１１８', '2018-01-19 15:57:05', '1');
INSERT INTO `blogger_picture` VALUES ('98', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1516351412198-格式工厂aasd.png', '格式工厂aasd', '2018-01-19 16:43:32', '1');
INSERT INTO `blogger_picture` VALUES ('99', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1517151427805-３.png', '３', '2018-01-28 22:57:07', '0');
INSERT INTO `blogger_picture` VALUES ('100', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1517151433358-４.png', '４', '2018-01-28 22:57:13', '0');
INSERT INTO `blogger_picture` VALUES ('101', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1517151438375-６.png', '６', '2018-01-28 22:57:18', '0');
INSERT INTO `blogger_picture` VALUES ('105', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519707724507-捕获 - 副本.jpeg', '捕获 - 副本', '2018-02-27 13:02:04', '0');
INSERT INTO `blogger_picture` VALUES ('106', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519707793387-Taylor-Swift-desktopsky-11091.jpeg', 'Taylor-Swift-desktopsky-11091', '2018-02-27 13:03:13', '0');
INSERT INTO `blogger_picture` VALUES ('107', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519707809321-album.jpeg', 'album', '2018-02-27 13:03:29', '0');
INSERT INTO `blogger_picture` VALUES ('108', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519707866674-Taylor-Swift-desktopsky-11091.jpeg', 'Taylor-Swift-desktopsky-11091', '2018-02-27 13:04:26', '0');
INSERT INTO `blogger_picture` VALUES ('109', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519707923117-album.jpeg', 'album', '2018-02-27 13:05:23', '0');
INSERT INTO `blogger_picture` VALUES ('110', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519709191423-Taylor-Swift-desktopsky-11091.jpeg', 'Taylor-Swift-desktopsky-11091', '2018-02-27 13:26:31', '0');
INSERT INTO `blogger_picture` VALUES ('111', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519717258933-捕获.png', '捕获', '2018-02-27 15:40:58', '0');
INSERT INTO `blogger_picture` VALUES ('112', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519717347865-捕获 - 副本.png', '捕获 - 副本', '2018-02-27 15:42:27', '0');
INSERT INTO `blogger_picture` VALUES ('113', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519718367518-Taylor-Swift-desktopsky-55931.jpeg', 'Taylor-Swift-desktopsky-55931', '2018-02-27 15:59:27', '0');
INSERT INTO `blogger_picture` VALUES ('114', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519718586706-album.jpeg', 'album', '2018-02-27 16:03:06', '0');
INSERT INTO `blogger_picture` VALUES ('115', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519718630140-捕获 - 副本.jpeg', '捕获 - 副本', '2018-02-27 16:03:50', '0');
INSERT INTO `blogger_picture` VALUES ('116', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519718706410-捕获 - 副本.jpeg', '捕获 - 副本', '2018-02-27 16:05:06', '0');
INSERT INTO `blogger_picture` VALUES ('117', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519719047106-album.jpeg', 'album', '2018-02-27 16:10:47', '0');
INSERT INTO `blogger_picture` VALUES ('118', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519719076804-捕获 - 副本.png', '捕获 - 副本', '2018-02-27 16:11:16', '0');
INSERT INTO `blogger_picture` VALUES ('119', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519719107548-taylor-swift_desktopsky_07.jpeg', 'taylor-swift_desktopsky_07', '2018-02-27 16:11:47', '0');
INSERT INTO `blogger_picture` VALUES ('120', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519719174300-捕获 - 副本.png', '捕获 - 副本', '2018-02-27 16:12:54', '0');
INSERT INTO `blogger_picture` VALUES ('121', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519719182789-捕获 - 副本.jpeg', '捕获 - 副本', '2018-02-27 16:13:02', '0');
INSERT INTO `blogger_picture` VALUES ('122', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519720634009-捕获 - 副本.jpeg', '捕获 - 副本', '2018-02-27 16:37:14', '0');
INSERT INTO `blogger_picture` VALUES ('123', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519720744527-Taylor-Swift-desktopsky-11091.jpeg', 'Taylor-Swift-desktopsky-11091', '2018-02-27 16:39:04', '0');
INSERT INTO `blogger_picture` VALUES ('124', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519720921462-album.jpeg', 'album', '2018-02-27 16:42:01', '0');
INSERT INTO `blogger_picture` VALUES ('125', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519720960729-91710b284d061bf34ede66c36251231.x-icon', '91710b284d061bf34ede66c36251231', '2018-02-27 16:42:40', '0');
INSERT INTO `blogger_picture` VALUES ('126', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519720966563-0782c798deb85deb14f8c4ae7978ac19183a15fa19385-e9JH52.x-icon', '0782c798deb85deb14f8c4ae7978ac19183a15fa19385-e9JH52', '2018-02-27 16:42:46', '0');
INSERT INTO `blogger_picture` VALUES ('127', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519720989088-png03_w_b.png', 'png03_w_b', '2018-02-27 16:43:09', '0');
INSERT INTO `blogger_picture` VALUES ('128', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519722473784-10.png', '10', '2018-02-27 17:07:53', '0');
INSERT INTO `blogger_picture` VALUES ('129', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519722662066-11.png', '11', '2018-02-27 17:11:02', '0');
INSERT INTO `blogger_picture` VALUES ('130', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519724174121-png01_w_b.jpeg', 'png01_w_b', '2018-02-27 17:36:14', '0');
INSERT INTO `blogger_picture` VALUES ('131', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519724194871-4444.jpeg', '4444', '2018-02-27 17:36:34', '0');
INSERT INTO `blogger_picture` VALUES ('132', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519724202103-格式工厂526622_梦境少女8_看图王.jpeg', '格式工厂526622_梦境少女8_看图王', '2018-02-27 17:36:42', '0');
INSERT INTO `blogger_picture` VALUES ('133', '1', '', '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519790930843-Image_057.png', 'Image_057', '2018-02-28 12:08:50', '0');
INSERT INTO `blogger_picture` VALUES ('134', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519896562041-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-01 17:29:22', '0');
INSERT INTO `blogger_picture` VALUES ('135', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1519897421823-blogger-1-avatar.octet-stream', 'blogger-1-avatar', '2018-03-01 17:43:41', '0');
INSERT INTO `blogger_picture` VALUES ('136', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1520040653461-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-03 09:30:53', '0');
INSERT INTO `blogger_picture` VALUES ('137', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1520041177636-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-03 09:39:37', '0');
INSERT INTO `blogger_picture` VALUES ('138', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1520041397890-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-03 09:43:18', '0');
INSERT INTO `blogger_picture` VALUES ('139', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1520041569721-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-03 09:46:09', '0');
INSERT INTO `blogger_picture` VALUES ('140', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1520042001063-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-03 09:53:21', '0');
INSERT INTO `blogger_picture` VALUES ('141', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1520042126845-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-03 09:55:26', '0');
INSERT INTO `blogger_picture` VALUES ('142', '1', null, '0', 'E:\\blog\\blogger\\image\\duan\\PRIVATE\\1520042296707-blogger-1-avatar.png', 'blogger-1-avatar', '2018-03-03 09:58:16', '0');
INSERT INTO `blogger_picture` VALUES ('143', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520045506096-once-avatar-1.png', 'once-avatar-1', '2018-03-03 10:52:51', '0');
INSERT INTO `blogger_picture` VALUES ('144', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520046113143-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:01:53', '0');
INSERT INTO `blogger_picture` VALUES ('145', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520046169083-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:02:49', '0');
INSERT INTO `blogger_picture` VALUES ('146', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520046338114-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:05:38', '0');
INSERT INTO `blogger_picture` VALUES ('147', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520046369252-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:06:09', '0');
INSERT INTO `blogger_picture` VALUES ('148', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520046387835-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:06:27', '0');
INSERT INTO `blogger_picture` VALUES ('149', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520046409821-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:06:49', '0');
INSERT INTO `blogger_picture` VALUES ('150', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520046529375-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:08:49', '0');
INSERT INTO `blogger_picture` VALUES ('151', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520047429782-once-avatar-1.png', 'once-avatar-1', '2018-03-03 11:23:49', '0');
INSERT INTO `blogger_picture` VALUES ('152', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520237548760-once-avatar-1.png', 'once-avatar-1', '2018-03-05 16:12:28', '0');
INSERT INTO `blogger_picture` VALUES ('153', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520237565808-once-avatar-1.png', 'once-avatar-1', '2018-03-05 16:12:45', '0');
INSERT INTO `blogger_picture` VALUES ('154', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520314802737-once-avatar-1.png', 'once-avatar-1', '2018-03-06 13:40:02', '0');
INSERT INTO `blogger_picture` VALUES ('155', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520400898468-once-avatar-1.png', 'once-avatar-1', '2018-03-07 13:34:58', '0');
INSERT INTO `blogger_picture` VALUES ('156', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520400906921-once-avatar-1.png', 'once-avatar-1', '2018-03-07 13:35:06', '0');
INSERT INTO `blogger_picture` VALUES ('157', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520401761021-once-avatar-1.png', 'once-avatar-1', '2018-03-07 13:49:21', '0');
INSERT INTO `blogger_picture` VALUES ('158', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520401774118-once-avatar-1.png', 'once-avatar-1', '2018-03-07 13:49:34', '0');
INSERT INTO `blogger_picture` VALUES ('159', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520401935078-once-avatar-1.png', 'once-avatar-1', '2018-03-07 13:52:15', '0');
INSERT INTO `blogger_picture` VALUES ('160', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1520499984071-once-avatar-22.png', 'once-avatar-22', '2018-03-08 17:06:24', '0');
INSERT INTO `blogger_picture` VALUES ('161', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1520500086570-once-avatar-22.png', 'once-avatar-22', '2018-03-08 17:08:06', '0');
INSERT INTO `blogger_picture` VALUES ('162', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1520500214423-once-avatar-22.png', 'once-avatar-22', '2018-03-08 17:10:14', '0');
INSERT INTO `blogger_picture` VALUES ('163', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1520500269857-once-avatar-22.png', 'once-avatar-22', '2018-03-08 17:11:09', '0');
INSERT INTO `blogger_picture` VALUES ('164', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1520500513580-once-avatar-22.png', 'once-avatar-22', '2018-03-08 17:15:13', '0');
INSERT INTO `blogger_picture` VALUES ('165', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1520585236625-once-avatar-22.png', 'once-avatar-22', '2018-03-09 16:47:16', '0');
INSERT INTO `blogger_picture` VALUES ('166', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1520836740484-once-avatar-1.png', 'once-avatar-1', '2018-03-12 14:39:00', '0');
INSERT INTO `blogger_picture` VALUES ('167', '24', '', '1', 'E:\\blog\\blogger\\image\\jack12\\PUBLIC\\1521018098675-once-avatar-24.png', 'once-avatar-24', '2018-03-14 17:01:38', '1');
INSERT INTO `blogger_picture` VALUES ('168', '25', '', '1', 'E:\\blog\\blogger\\image\\rose13\\PUBLIC\\1521018275755-once-avatar-25.png', 'once-avatar-25', '2018-03-14 17:04:35', '1');
INSERT INTO `blogger_picture` VALUES ('169', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1521194415541-once-avatar-1.png', 'once-avatar-1', '2018-03-16 18:00:15', '0');
INSERT INTO `blogger_picture` VALUES ('170', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1521287706735-once-avatar-22.png', 'once-avatar-22', '2018-03-17 19:55:06', '0');
INSERT INTO `blogger_picture` VALUES ('171', '22', '', '1', 'E:\\blog\\blogger\\image\\spring\\PUBLIC\\1521298857878-once-avatar-22.png', 'once-avatar-22', '2018-03-17 23:00:57', '1');
INSERT INTO `blogger_picture` VALUES ('172', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1521721443935-once-avatar-1.png', 'once-avatar-1', '2018-03-22 20:24:03', '0');
INSERT INTO `blogger_picture` VALUES ('173', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1521721605300-once-avatar-1.png', 'once-avatar-1', '2018-03-22 20:26:45', '0');
INSERT INTO `blogger_picture` VALUES ('174', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1521721765281-once-avatar-1.png', 'once-avatar-1', '2018-03-22 20:29:25', '0');
INSERT INTO `blogger_picture` VALUES ('175', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1521721850874-once-avatar-1.png', 'once-avatar-1', '2018-03-22 20:30:50', '0');
INSERT INTO `blogger_picture` VALUES ('176', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1521722171411-once-avatar-1.png', 'once-avatar-1', '2018-03-22 20:36:11', '0');
INSERT INTO `blogger_picture` VALUES ('177', '1', '', '13', 'E:\\blog\\blogger\\image\\duan\\DEFAULT_BLOGGER_AVATAR\\1521769880058-7.png', '7', '2018-03-23 09:51:20', '0');
INSERT INTO `blogger_picture` VALUES ('179', '29', '', '1', 'E:\\blog\\blogger\\image\\tony14\\PUBLIC\\1521770698596-once-avatar-29.png', 'once-avatar-29', '2018-03-23 10:04:58', '1');
INSERT INTO `blogger_picture` VALUES ('180', '1', '', '1', 'E:\\blog\\blogger\\image\\duan\\PUBLIC\\1522035238942-once-avatar-1.png', 'once-avatar-1', '2018-03-26 11:33:58', '1');

-- ----------------------------
-- Table structure for `blogger_profile`
-- ----------------------------
DROP TABLE IF EXISTS `blogger_profile`;
CREATE TABLE `blogger_profile` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '博主资料id',
  `blogger_id` int(11) unsigned NOT NULL COMMENT '博主id',
  `phone` varchar(20) DEFAULT NULL COMMENT '电话',
  `email` varchar(50) DEFAULT NULL COMMENT '邮箱',
  `about_me` text COMMENT '关于我',
  `intro` text COMMENT '一句话简介',
  `avatar_id` int(10) unsigned DEFAULT NULL COMMENT '博主头像',
  PRIMARY KEY (`id`),
  UNIQUE KEY `blogger_id` (`blogger_id`),
  UNIQUE KEY `phone` (`phone`),
  KEY `avatar_id` (`avatar_id`),
  CONSTRAINT `blogger_profile_ibfk_1` FOREIGN KEY (`blogger_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `blogger_profile_ibfk_2` FOREIGN KEY (`avatar_id`) REFERENCES `blogger_picture` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blogger_profile
-- ----------------------------
INSERT INTO `blogger_profile` VALUES ('1', '1', '15865656489', '2213994603@qq.com', '勇敢产生在斗争中，勇气是在每天每天对困难的顽强抵抗中养成的。我们青年的箴言就是勇敢、顽强、坚定，就是排除一切障碍。', '欢迎来到 Duan 的博客', '180');
INSERT INTO `blogger_profile` VALUES ('10', '4', '18356987456', 'ee@qq.com', '关于我', '546', null);
INSERT INTO `blogger_profile` VALUES ('18', '22', '18328083378', '2217611834@qq.com', '如果增大schedule_remark字段的内容，就会报上面的错误。Row size too large。表示行的内容太多了，就是线路220567存储的内容太多了。后面的You have to change some columns to TEXT or BLOBs具有迷惑性，因为schedule_remark字段的内容并没有增加到65k', '如果增大schedule_remark字段的内', '171');
INSERT INTO `blogger_profile` VALUES ('20', '24', '18328083222', '2217611834@qq.com', 'ddd', 'blog title', '167');
INSERT INTO `blogger_profile` VALUES ('21', '25', '18328083221', '22@gmail.com', '4', '2', '168');
INSERT INTO `blogger_profile` VALUES ('23', '27', '18325487455', 'duan_jia_ning@163.com', '勇敢产生在斗争中，勇气是在每天每天对困难的顽强抵抗中养成的。我们青年的箴言就是勇敢、顽强、坚定，就是排除一切障碍。\n', '欢迎来到 Tony 的博客', null);
INSERT INTO `blogger_profile` VALUES ('24', '28', '18325487457', 'duan_jia_ning@163.com', '勇敢产生在斗争中，勇气是在每天每天对困难的顽强抵抗中养成的。我们青年的箴言就是勇敢、顽强、坚定，就是排除一切障碍。', '欢迎来到 tony13 的博客', null);
INSERT INTO `blogger_profile` VALUES ('25', '29', '18325487445', 'duan_jia_ning@163.com', '勇敢产生在斗争中，勇气是在每天每天对困难的顽强抵抗中养成的。我们青年的箴言就是勇敢、顽强、坚定，就是排除一切障碍。', ' 欢迎来到 tony14 的博客', '179');

-- ----------------------------
-- Table structure for `blogger_setting`
-- ----------------------------
DROP TABLE IF EXISTS `blogger_setting`;
CREATE TABLE `blogger_setting` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `main_page_nav_pos` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '博主主页个人信息栏位置，0为左，1为右',
  `blogger_id` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`),
  KEY `blogger_id` (`blogger_id`),
  CONSTRAINT `blogger_setting_ibfk_1` FOREIGN KEY (`blogger_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blogger_setting
-- ----------------------------
INSERT INTO `blogger_setting` VALUES ('2', '0', '1');
INSERT INTO `blogger_setting` VALUES ('9', '0', '24');
INSERT INTO `blogger_setting` VALUES ('10', '0', '25');
INSERT INTO `blogger_setting` VALUES ('11', '0', '22');
INSERT INTO `blogger_setting` VALUES ('12', '0', '27');
INSERT INTO `blogger_setting` VALUES ('14', '0', '29');

-- ----------------------------
-- Table structure for `blog_admire`
-- ----------------------------
DROP TABLE IF EXISTS `blog_admire`;
CREATE TABLE `blog_admire` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '赞赏记录表id',
  `blog_id` int(10) unsigned NOT NULL COMMENT '交易针对的博文id',
  `paier_id` int(11) DEFAULT NULL COMMENT '付钱者id',
  `money` float(10,0) unsigned NOT NULL DEFAULT '0' COMMENT '金额',
  `tran_date` datetime NOT NULL COMMENT '交易时间',
  PRIMARY KEY (`id`),
  KEY `blog_id` (`blog_id`),
  CONSTRAINT `blog_admire_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_admire
-- ----------------------------

-- ----------------------------
-- Table structure for `blog_category`
-- ----------------------------
DROP TABLE IF EXISTS `blog_category`;
CREATE TABLE `blog_category` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '博文类别id',
  `blogger_id` int(10) unsigned DEFAULT NULL COMMENT '创建该类别的博主',
  `icon_id` int(10) unsigned DEFAULT NULL COMMENT '类别图标',
  `title` varchar(20) NOT NULL COMMENT '类别名',
  `bewrite` text COMMENT '类别描述',
  `create_date` datetime NOT NULL COMMENT '类别创建时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `blogger_id` (`blogger_id`,`title`),
  KEY `icon_id` (`icon_id`),
  CONSTRAINT `blog_category_ibfk_1` FOREIGN KEY (`blogger_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `blog_category_ibfk_2` FOREIGN KEY (`icon_id`) REFERENCES `blogger_picture` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=50 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_category
-- ----------------------------
INSERT INTO `blog_category` VALUES ('1', '1', null, '编程语言', 'java c c++ ', '2017-12-12 18:46:52');
INSERT INTO `blog_category` VALUES ('2', '1', null, '网络', 'safd', '2017-12-12 18:47:25');
INSERT INTO `blog_category` VALUES ('5', '1', '96', 'VR', 'jQuery 教程 jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 jQuery 很容易学习。 本章节的每一篇都包含了在线实例 通过本站的在线编辑器', '2017-12-14 02:43:40');
INSERT INTO `blog_category` VALUES ('15', '1', null, 'android', 'Query 教程 jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 jQuery 很容易学习。 本章节的每一篇都包含了在线实例 通过本站的在线编辑器Query 教程 jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 jQuery 很容易学习。 本章节的每一篇都包含了在线实例 通过本站的在线编辑器Query 教程 jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 jQuery 很容易学习。 本章节的每一篇都包含了在线实例 通过本站的在线编辑器Query 教程 jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 jQuery 很容易学习。 本章节的每一篇都包含了在线实例 通过本站的在线编辑器Query 教程 jQuery 是一个 JavaScript 库。 jQuery 极大地简化了 JavaScript 编程。 jQuery 很容易学习。 本章节的每一篇都包含了在线实例 通过本站的在线编辑器', '2018-02-28 15:47:40');
INSERT INTO `blog_category` VALUES ('25', '1', null, '随笔', null, '2018-02-28 15:47:41');
INSERT INTO `blog_category` VALUES ('27', '22', null, 'java', 'java知识', '2018-03-07 15:52:51');
INSERT INTO `blog_category` VALUES ('28', '22', null, 'tcp', '网络', '2018-03-07 15:55:48');
INSERT INTO `blog_category` VALUES ('29', '22', null, 'java-se-1', 'java se', '2018-03-07 16:13:23');
INSERT INTO `blog_category` VALUES ('35', '24', null, 'java', '', '2018-03-14 16:47:12');
INSERT INTO `blog_category` VALUES ('39', '27', null, 'java - 集合', '', '2018-03-23 09:30:30');
INSERT INTO `blog_category` VALUES ('40', '27', null, '网络', '计算机网络', '2018-03-23 09:30:42');
INSERT INTO `blog_category` VALUES ('41', '27', null, 'OS', '操作系统', '2018-03-23 09:30:52');
INSERT INTO `blog_category` VALUES ('47', '29', null, 'javaSE', '', '2018-03-23 10:06:06');
INSERT INTO `blog_category` VALUES ('48', '29', null, '集合', 'java 集合框架', '2018-03-23 10:06:22');
INSERT INTO `blog_category` VALUES ('49', '29', null, '设计模式', '23种常用设计模式', '2018-03-23 10:06:44');

-- ----------------------------
-- Table structure for `blog_collect`
-- ----------------------------
DROP TABLE IF EXISTS `blog_collect`;
CREATE TABLE `blog_collect` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '收藏博文表id',
  `blog_id` int(11) unsigned NOT NULL COMMENT '收藏的博文id',
  `collector_id` int(10) unsigned NOT NULL COMMENT '收藏者id',
  `reason` text COMMENT '收藏的理由',
  `collect_date` datetime NOT NULL COMMENT '收藏时间',
  `category_id` int(10) unsigned DEFAULT '0' COMMENT '收藏到自己的哪一个类别下',
  PRIMARY KEY (`id`),
  UNIQUE KEY `blog_id` (`blog_id`,`collector_id`),
  KEY `blogger_id` (`collector_id`),
  KEY `category_id` (`category_id`),
  CONSTRAINT `blog_collect_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `blog_collect_ibfk_2` FOREIGN KEY (`collector_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=57 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_collect
-- ----------------------------
INSERT INTO `blog_collect` VALUES ('40', '168', '22', null, '2018-03-13 15:20:36', '0');
INSERT INTO `blog_collect` VALUES ('45', '171', '1', null, '2018-03-14 16:48:42', '0');
INSERT INTO `blog_collect` VALUES ('52', '142', '1', null, '2018-03-31 11:30:14', '0');
INSERT INTO `blog_collect` VALUES ('53', '167', '22', null, '2018-03-31 16:06:40', '0');
INSERT INTO `blog_collect` VALUES ('54', '167', '25', null, '2018-03-31 16:07:46', '0');
INSERT INTO `blog_collect` VALUES ('55', '167', '27', null, '2018-03-31 16:08:44', '0');
INSERT INTO `blog_collect` VALUES ('56', '167', '29', null, '2018-03-31 16:10:49', '0');

-- ----------------------------
-- Table structure for `blog_comment`
-- ----------------------------
DROP TABLE IF EXISTS `blog_comment`;
CREATE TABLE `blog_comment` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `blog_id` int(10) unsigned NOT NULL COMMENT '评论针对的博客id',
  `spokesman_id` int(10) unsigned DEFAULT NULL COMMENT '评论者id',
  `listener_id` int(10) unsigned DEFAULT NULL COMMENT '被评论者id',
  `content` text NOT NULL COMMENT '评论内容',
  `release_date` datetime NOT NULL COMMENT '评论时间',
  `state` int(11) NOT NULL DEFAULT '0' COMMENT '状态（审核中...）',
  PRIMARY KEY (`id`),
  KEY `blog_id` (`blog_id`),
  KEY `spokesman_id` (`spokesman_id`),
  KEY `listener_id` (`listener_id`),
  CONSTRAINT `blog_comment_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `blog_comment_ibfk_2` FOREIGN KEY (`spokesman_id`) REFERENCES `blogger_account` (`id`) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT `blog_comment_ibfk_3` FOREIGN KEY (`listener_id`) REFERENCES `blogger_account` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_comment
-- ----------------------------
INSERT INTO `blog_comment` VALUES ('3', '169', '1', '1', '只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、', '2018-03-13 17:36:48', '1');
INSERT INTO `blog_comment` VALUES ('12', '169', '1', '1', 'u>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。</u>一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)\n\nn称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，<i> 若有某个辅助函数f(n),使得当n趋近于无穷大时，*T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。</i>\n\n算法中语句执行次数为一个常数', '2018-03-13 17:50:45', '1');
INSERT INTO `blog_comment` VALUES ('13', '169', '1', '1', '阿斯蒂芬三', '2018-03-13 17:51:48', '1');
INSERT INTO `blog_comment` VALUES ('15', '169', '1', '1', 'sadffffffffff', '2018-03-13 18:17:10', '1');
INSERT INTO `blog_comment` VALUES ('16', '169', '22', '1', 'asdf', '2018-03-13 18:17:52', '1');
INSERT INTO `blog_comment` VALUES ('17', '169', '22', '1', '算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示， 若有某个辅助函数f(n),使得', '2018-03-13 18:18:07', '1');
INSERT INTO `blog_comment` VALUES ('18', '167', '22', '1', '留下一个留言', '2018-03-13 18:22:21', '1');
INSERT INTO `blog_comment` VALUES ('19', '167', '22', '1', 'fsdg', '2018-03-13 18:22:27', '1');
INSERT INTO `blog_comment` VALUES ('20', '167', '22', '1', 'aaaaa', '2018-03-13 18:27:08', '1');
INSERT INTO `blog_comment` VALUES ('23', '167', '1', '1', 'ddff', '2018-03-13 18:28:28', '1');
INSERT INTO `blog_comment` VALUES ('26', '170', '1', '1', 'xxxxxxxxx', '2018-03-14 09:37:55', '1');
INSERT INTO `blog_comment` VALUES ('27', '167', '1', '1', '上面已经说了一下newNode方法的，除了用于创建新元素以外，在LinkedHashMap中，newNode方法还额外做了一件事情：将当前元素链接到链表尾，即创建LinkedHashMap专用的LinkedHashMap.Entry，构造该节点的前驱和后继以维护其“插入顺序”。对应linkNodeLast方法。', '2018-03-17 22:54:02', '1');
INSERT INTO `blog_comment` VALUES ('28', '167', '1', '1', 'newNode方法的，除了用于创建新元素以外', '2018-03-17 22:55:53', '1');
INSERT INTO `blog_comment` VALUES ('29', '167', '1', '1', 'newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外', '2018-03-17 22:56:00', '1');
INSERT INTO `blog_comment` VALUES ('30', '175', '27', '27', '第一个留言', '2018-03-23 09:33:37', '1');
INSERT INTO `blog_comment` VALUES ('31', '175', '27', '27', '得到', '2018-03-23 09:33:50', '1');
INSERT INTO `blog_comment` VALUES ('32', '142', '1', '22', 'liugeya', '2018-03-31 11:29:52', '1');
INSERT INTO `blog_comment` VALUES ('33', '167', '25', '1', '我也来留一个', '2018-03-31 16:25:39', '1');
INSERT INTO `blog_comment` VALUES ('34', '167', '25', '1', 'de方法的，除了用于创建新元素以外newNode方法的，', '2018-03-31 16:25:44', '1');
INSERT INTO `blog_comment` VALUES ('35', '167', '25', '1', '了用于创建新元素以外newNode方法的，除了用于创', '2018-03-31 16:25:50', '1');
INSERT INTO `blog_comment` VALUES ('36', '167', '25', '1', '以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newNode方法的，除了用于创建新元素以外newN', '2018-03-31 16:25:56', '1');
INSERT INTO `blog_comment` VALUES ('37', '168', '1', '1', '正在', '2018-04-03 11:37:21', '1');

-- ----------------------------
-- Table structure for `blog_complain`
-- ----------------------------
DROP TABLE IF EXISTS `blog_complain`;
CREATE TABLE `blog_complain` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '表id',
  `complainer_id` int(10) unsigned NOT NULL COMMENT '投诉者id',
  `blog_id` int(10) unsigned NOT NULL COMMENT '投诉的博文',
  `content` varchar(255) NOT NULL COMMENT '投诉理由',
  `time` datetime NOT NULL COMMENT '投诉时间',
  PRIMARY KEY (`id`),
  KEY `blog_id` (`blog_id`),
  KEY `complainer_id` (`complainer_id`),
  CONSTRAINT `blog_complain_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `blog_complain_ibfk_2` FOREIGN KEY (`complainer_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_complain
-- ----------------------------

-- ----------------------------
-- Table structure for `blog_label`
-- ----------------------------
DROP TABLE IF EXISTS `blog_label`;
CREATE TABLE `blog_label` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `blogger_id` int(10) unsigned DEFAULT NULL COMMENT '创建该标签的博主',
  `title` varchar(20) NOT NULL COMMENT '标签名',
  `create_date` datetime NOT NULL COMMENT '标签创建时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `blogger_id_2` (`blogger_id`,`title`),
  KEY `blogger_id` (`blogger_id`),
  CONSTRAINT `blog_label_ibfk_1` FOREIGN KEY (`blogger_id`) REFERENCES `blogger_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=67 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_label
-- ----------------------------
INSERT INTO `blog_label` VALUES ('3', '1', 'TCP/IP', '2017-12-12 18:42:16');
INSERT INTO `blog_label` VALUES ('37', '1', 'java', '2018-03-05 11:51:14');
INSERT INTO `blog_label` VALUES ('39', '1', '1212', '2018-03-05 11:57:26');
INSERT INTO `blog_label` VALUES ('47', '1', '标签吗', '2018-03-05 11:58:13');
INSERT INTO `blog_label` VALUES ('48', '22', 'java se', '2018-03-07 15:52:39');
INSERT INTO `blog_label` VALUES ('49', '22', 'Jakarta EE', '2018-03-07 15:57:36');
INSERT INTO `blog_label` VALUES ('50', '22', '分布式', '2018-03-07 16:12:35');
INSERT INTO `blog_label` VALUES ('53', '1', 'cccc', '2018-03-14 10:19:59');
INSERT INTO `blog_label` VALUES ('54', '24', '存储', '2018-03-14 16:47:02');
INSERT INTO `blog_label` VALUES ('58', '27', 'java', '2018-03-23 09:30:02');
INSERT INTO `blog_label` VALUES ('59', '27', '多线程', '2018-03-23 09:30:15');
INSERT INTO `blog_label` VALUES ('60', '27', '并发', '2018-03-23 09:30:21');
INSERT INTO `blog_label` VALUES ('64', '29', 'java', '2018-03-23 10:05:15');
INSERT INTO `blog_label` VALUES ('66', '29', '操作系统', '2018-03-23 10:05:34');

-- ----------------------------
-- Table structure for `blog_like`
-- ----------------------------
DROP TABLE IF EXISTS `blog_like`;
CREATE TABLE `blog_like` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '博文喜欢表id',
  `blog_id` int(10) unsigned NOT NULL COMMENT '被喜欢的文章',
  `liker_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '仰慕者（给出like的人）id，未注册读者用0表示',
  `like_date` datetime NOT NULL COMMENT '时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `admirer_id` (`liker_id`,`blog_id`),
  KEY `blog_like_ibfk_1` (`blog_id`),
  CONSTRAINT `blog_like_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_like
-- ----------------------------
INSERT INTO `blog_like` VALUES ('35', '168', '22', '2018-03-13 15:21:29');
INSERT INTO `blog_like` VALUES ('39', '169', '22', '2018-03-13 18:18:37');
INSERT INTO `blog_like` VALUES ('41', '167', '22', '2018-03-13 18:31:49');
INSERT INTO `blog_like` VALUES ('47', '171', '1', '2018-03-14 16:48:43');
INSERT INTO `blog_like` VALUES ('50', '142', '1', '2018-03-14 16:59:59');
INSERT INTO `blog_like` VALUES ('51', '166', '1', '2018-03-14 17:00:03');
INSERT INTO `blog_like` VALUES ('54', '173', '25', '2018-03-14 17:03:08');
INSERT INTO `blog_like` VALUES ('55', '173', '1', '2018-03-14 17:04:56');
INSERT INTO `blog_like` VALUES ('60', '168', '1', '2018-03-19 18:20:23');
INSERT INTO `blog_like` VALUES ('64', '167', '29', '2018-03-23 10:23:48');
INSERT INTO `blog_like` VALUES ('65', '169', '1', '2018-03-30 14:42:00');
INSERT INTO `blog_like` VALUES ('66', '167', '25', '2018-03-31 16:07:48');
INSERT INTO `blog_like` VALUES ('67', '167', '27', '2018-03-31 16:08:47');

-- ----------------------------
-- Table structure for `blog_statistics`
-- ----------------------------
DROP TABLE IF EXISTS `blog_statistics`;
CREATE TABLE `blog_statistics` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '表id',
  `blog_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '对应博文id',
  `comment_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '评论次数',
  `view_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '博文浏览次数',
  `reply_comment_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '博主回复该博文评论的次数',
  `collect_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '收藏次数',
  `complain_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '投诉次数',
  `share_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '分享次数',
  `admire_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '赞赏次数',
  `like_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '喜欢次数',
  `release_date` date NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `blog_id` (`blog_id`),
  CONSTRAINT `blog_statistics_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=171 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_statistics
-- ----------------------------
INSERT INTO `blog_statistics` VALUES ('151', '141', '0', '7', '0', '0', '0', '0', '0', '0', '2018-03-07');
INSERT INTO `blog_statistics` VALUES ('152', '142', '1', '8', '0', '1', '0', '0', '0', '1', '2018-03-08');
INSERT INTO `blog_statistics` VALUES ('154', '162', '0', '3', '0', '0', '0', '0', '0', '0', '2018-03-09');
INSERT INTO `blog_statistics` VALUES ('155', '163', '0', '2', '0', '0', '0', '0', '0', '0', '2018-03-09');
INSERT INTO `blog_statistics` VALUES ('156', '165', '0', '1', '0', '0', '0', '0', '0', '0', '2018-03-09');
INSERT INTO `blog_statistics` VALUES ('157', '166', '0', '1', '0', '0', '0', '0', '0', '1', '2018-03-09');
INSERT INTO `blog_statistics` VALUES ('158', '167', '11', '120', '0', '4', '0', '0', '0', '4', '2018-03-12');
INSERT INTO `blog_statistics` VALUES ('159', '168', '1', '30', '0', '1', '0', '0', '0', '2', '2018-03-12');
INSERT INTO `blog_statistics` VALUES ('160', '169', '6', '96', '0', '0', '0', '0', '0', '2', '2018-03-12');
INSERT INTO `blog_statistics` VALUES ('161', '170', '1', '9', '0', '0', '0', '0', '0', '0', '2018-03-12');
INSERT INTO `blog_statistics` VALUES ('162', '171', '0', '5', '0', '1', '0', '0', '0', '1', '2018-03-14');
INSERT INTO `blog_statistics` VALUES ('163', '172', '0', '4', '0', '0', '0', '0', '0', '0', '2018-03-14');
INSERT INTO `blog_statistics` VALUES ('164', '173', '0', '5', '0', '0', '0', '0', '0', '2', '2018-03-14');
INSERT INTO `blog_statistics` VALUES ('165', '174', '0', '3', '0', '0', '0', '0', '0', '0', '2018-03-14');
INSERT INTO `blog_statistics` VALUES ('166', '175', '2', '8', '0', '0', '0', '0', '0', '0', '2018-03-23');
INSERT INTO `blog_statistics` VALUES ('169', '178', '0', '2', '0', '0', '0', '0', '0', '0', '2018-03-23');
INSERT INTO `blog_statistics` VALUES ('170', '179', '0', '20', '0', '0', '0', '0', '0', '0', '2018-04-03');
